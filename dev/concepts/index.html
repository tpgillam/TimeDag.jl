<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Concepts · TimeDag.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://tpgillam.github.io/TimeDag.jl/concepts/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.png" alt="TimeDag.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.png" alt="TimeDag.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">TimeDag.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Concepts</a><ul class="internal"><li><a class="tocitem" href="#Time-series"><span>Time-series</span></a></li><li><a class="tocitem" href="#Functions-of-time-series"><span>Functions of time-series</span></a></li><li><a class="tocitem" href="#Classes-of-function"><span>Classes of function</span></a></li><li><a class="tocitem" href="#Computational-graph"><span>Computational graph</span></a></li></ul></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../reference/fundamentals/">Fundamentals</a></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Node ops</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../reference/align/">Alignment ops</a></li><li><a class="tocitem" href="../reference/arithmetic/">Arithmetic</a></li><li><a class="tocitem" href="../reference/online_windowed/">Online &amp; windowed</a></li><li><a class="tocitem" href="../reference/misc_ops/">Miscellaneous</a></li><li><a class="tocitem" href="../reference/sources/">Sources</a></li></ul></li><li><a class="tocitem" href="../reference/creating_ops/">Creating operations</a></li><li><a class="tocitem" href="../reference/internals/">Internals</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Concepts</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Concepts</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/tpgillam/TimeDag.jl/blob/main/docs/src/concepts.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Concepts"><a class="docs-heading-anchor" href="#Concepts">Concepts</a><a id="Concepts-1"></a><a class="docs-heading-anchor-permalink" href="#Concepts" title="Permalink"></a></h1><p>This document explains some key concepts and terminology.</p><p>We begin with a mathematical framework for expressing time-series operations. This is then used to form analogies with code in <code>TimeDag</code>, and motivate some of the design decisions.</p><h2 id="Time-series"><a class="docs-heading-anchor" href="#Time-series">Time-series</a><a id="Time-series-1"></a><a class="docs-heading-anchor-permalink" href="#Time-series" title="Permalink"></a></h2><p>We define a time-series <span>$x\ \in \mathcal{TS} \subset \mathcal{T} \times \mathcal{X}$</span> to be an ordered sequence of <span>$N$</span> time-value pairs:</p><p class="math-container">\[\begin{aligned}
x   &amp;= \{(t_i, x_i)\ |\ i \in [1, N]\}\\
t_i &amp;\in \mathcal{T}_x\ \forall i, \quad \mathcal{T}_x = [t_1, \infty) \subset \mathcal{T}\\
x_i &amp;\in \mathcal{X}\ \forall i\\
t_i &amp;&gt; t_{i-1}\ \forall i.
\end{aligned}\]</p><p>Here we use <span>$\mathcal{T}$</span> to denote the type of time.<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup> We only require that there is a total order on <span>$\mathcal{T}$</span> — but thinking about it as a real number is a good analogy. We also, somewhat sloppily, identify <span>$\infty$</span> with <span>$max \mathcal{T}$</span>.</p><p>This restriction may be relaxed in the future.</p><p>Colloquially, we will refer to a time-value pair as a <em>knot</em>.<sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup></p><p><span>$\mathcal{T}_x$</span> is the semi-infinite interval bounded below by the time of the first knot in <span>$x$</span>.</p><p>We define the <a href="../reference/fundamentals/#TimeDag.value_type"><code>TimeDag.value_type</code></a> of <span>$x$</span> to be the set <span>$\mathcal{X}$</span> above, and in practice this can be any Julia type.</p><p><code>TimeDag</code> primarily represents a time-series as a <a href="../reference/fundamentals/#TimeDag.Node"><code>TimeDag.Node</code></a>.  It also stores time-series data in memory in the <a href="../reference/fundamentals/#TimeDag.Block"><code>Block</code></a> type.</p><p>Here is a visualisation of a time-series <span>$x$</span>:</p><p><img src="../assets/time_series.png" alt="A time series"/></p><h3 id="Functional-interpretation"><a class="docs-heading-anchor" href="#Functional-interpretation">Functional interpretation</a><a id="Functional-interpretation-1"></a><a class="docs-heading-anchor-permalink" href="#Functional-interpretation" title="Permalink"></a></h3><p>We can also consider <span>$x$</span> to be a function, <span>$x : \mathcal{T}_x \rightarrow \mathcal{X}$</span>. This is defined <span>$x(t) = \max_i\ x_i\ \textrm{s.t.}\ t_i \leq t$</span>.</p><p>Informally, this means that whenever we observe a value <span>$x_i$</span>, the &#39;value of&#39; the time-series is <span>$x_i$</span> until such time as we observe <span>$x_{i+1}$</span>.</p><p>Sometimes it is useful to define <span>$x(t_{-}) = \oslash\ \forall\ t_{-} \in \mathcal{T} \setminus \mathcal{T}_x$</span>. Here, <span>$\oslash$</span> is a placeholder element that simply means &quot;no value&quot;.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>Note that time is <em>strictly increasing</em>, and repeated times are not permitted. This conceptual choice is necessary to consider <span>$x$</span> to be a map from time to value as above. Without this restriction, there is an ambiguity whenever a time is repeated.</p></div></div><h2 id="Functions-of-time-series"><a class="docs-heading-anchor" href="#Functions-of-time-series">Functions of time-series</a><a id="Functions-of-time-series-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-of-time-series" title="Permalink"></a></h2><h3 id="General-case"><a class="docs-heading-anchor" href="#General-case">General case</a><a id="General-case-1"></a><a class="docs-heading-anchor-permalink" href="#General-case" title="Permalink"></a></h3><p>We wish to define a general notion of a function <span>$f : \mathcal{TS} \times \cdots \times \mathcal{TS} \rightarrow \mathcal{TS}$</span>. Let <span>$z = f(x, y, \ldots)$</span>, where <span>$x$</span>, <span>$y$</span> and <span>$z$</span> are all time-series.</p><p>Firstly, we define an indicator-like function <span>$f_t(t, \ldots) \in \{0,1\}$</span>, which returns <span>$1$</span> iff we should emit a value at time <span>$t$</span>:</p><p class="math-container">\[\{t_i\} = \{t \in \mathcal{T}\ |\ f_t(t, \{x(t&#39;) | t&#39; \leq t\}, \{y(t&#39;) | t&#39; \leq t\}, \ldots) = 1\}\]</p><p>Colloquially, whenever <span>$f_t$</span> returns <span>$1$</span> we say that <span>$z$</span> <em>ticks</em>, i.e. emits a knot.</p><p>Then, we require that each value <span>$z_i$</span> at time <span>$t_i$</span> can be written as the result of a function <span>$f&#39;$</span>:</p><p class="math-container">\[z_i = f&#39;(t_i, \{x(t) | t \leq t_i\}, \{y(t) | t \leq t_i\}, \ldots).\]</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>Let us unpack this notation a bit:</p><ul><li>Knots of <span>$z$</span> are only allowed to depend on <em>non-future</em> values of <span>$x$</span> and <span>$y$</span>.</li><li><span>$z$</span> can tick whenever it likes, possibly dependent on values of <span>$x$</span> and <span>$y$</span>.</li><li>The knot emitted can be a function of time.</li></ul><p>The first of these is an important requirement, and <code>TimeDag</code> aims to enforce this structurally.</p></div></div><h3 id="Parameters"><a class="docs-heading-anchor" href="#Parameters">Parameters</a><a id="Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Parameters" title="Permalink"></a></h3><p>In the above discussion, all arguments to <span>$f$</span> are time-series. Such functions could additionally have some other non-time-series constant parameters, which we will denote <span>$\theta\in\Theta$</span>. Strictly mathematically, note that a &quot;constant&quot; can just be viewed as a time-series with a single observation at <span>$min \mathcal{T}$</span>; so the above description is still fully general.</p><p>In practice (for efficient implementation) we will want function <span>$f : \Theta \times \mathcal{TS} \times \cdots \rightarrow \mathcal{TS}$</span>. So, <span>$f(\theta, x, y, \ldots)$</span> then has some constant parameter(s) <span>$\theta$</span>.</p><p>We&#39;ll continue to drop the explicit <span>$\theta$</span> dependence where it isn&#39;t interesting, to simplify notation.</p><h3 id="Explicit-state"><a class="docs-heading-anchor" href="#Explicit-state">Explicit state</a><a id="Explicit-state-1"></a><a class="docs-heading-anchor-permalink" href="#Explicit-state" title="Permalink"></a></h3><p>It is useful to re-write the value computation by introducing the notion of a &#39;state&#39; <span>$\zeta_i$</span>:</p><p class="math-container">\[\begin{aligned}
z_i, \zeta_i &amp;= f_v(t_i, \zeta_{i-1}, x(t_i), y(t_i), \ldots)\\
\end{aligned}\]</p><p>Each state <span>$\zeta_{i-1}$</span> needs to package as much information about the history of the inputs as necessary to compute each <span>$z_i$</span> (as well as the new state <span>$\zeta_i$</span>).</p><h3 id="Batching"><a class="docs-heading-anchor" href="#Batching">Batching</a><a id="Batching-1"></a><a class="docs-heading-anchor-permalink" href="#Batching" title="Permalink"></a></h3><p>Note that, even after the re-arrangement in <a href="#Explicit-state">Explicit state</a>, <span>$f_t$</span> is still a bit awkward. One cannot directly implement it — otherwise one has to call <span>$f_t$</span> for every <span>$t$</span> in an infinite (or at least very large) set.</p><p>First, let us introduce the notion of slicing. Define an interval <span>$\delta = [t_1,t_2) \subset \mathcal{T}$</span>.<sup class="footnote-reference"><a id="citeref-3" href="#footnote-3">[3]</a></sup> Then, the slice of <span>$x$</span> over <span>$\delta$</span>, which we&#39;ll write as <span>$x&#39; = x[\delta]$</span>, is a new time-series with support <span>$\mathcal{T}_{x&#39;} = \delta \cap \mathcal{T}_x$</span>.</p><p>Let <span>$\{\delta_i\}$</span> represent an ordered non-overlapping set of intervals, whose union covers all of <span>$\mathcal{T}$</span>. We then write, analogous to the definition of <span>$f_v$</span>:</p><p class="math-container">\[z[\delta_i], \zeta_{\sup \delta_i} = f_b(\delta_i, \zeta_{\sup \delta_{i-1}}, x[\delta_i], y[\delta_i], \ldots).\]</p><p>This function outputs knots — time-value pairs — rather than just the values, and hence performs the roles of both <span>$f_t$</span> and <span>$f_v$</span> previously.</p><p><strong>NB</strong> <span>$\sup\delta_i$</span> indicates the supremum of the interval <span>$\delta_i$</span>, i.e. the upper bound. The state <span>$\zeta$</span> is only subscripted by this upper bound; i.e. by a time, because it should not be path dependent. i.e. for a given time-series operation, we should always end up with the same state at a particular time, regardless of how many batches we have used to get there.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>It is useful to emphasise this distinction:</p><ul><li><span>$f$</span> — a time-series operation. This is <a href="../reference/fundamentals/#TimeDag.NodeOp"><code>TimeDag.NodeOp</code></a>.</li><li><span>$f_b$</span> — the <em>implementation</em> of <span>$f$</span>. This is <a href="../reference/internals/#TimeDag.run_node!"><code>TimeDag.run_node!</code></a>.</li></ul><p>Helpfully, often <span>$f$</span> has simple semantics &amp; behaviour that can be reasoned about. The implementation details can be ignored in this reasoning.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>A little thought shows that <span>$f_b$</span>, and hence <a href="../reference/internals/#TimeDag.run_node!"><code>TimeDag.run_node!</code></a>, can express <em>illegal</em> time-series operations that future-peek. Care must be taken when implementing this low-level interface!</p><p>Where possible, when custom operations are required, use the higher-level abstractions referred to below.</p></div></div><h2 id="Classes-of-function"><a class="docs-heading-anchor" href="#Classes-of-function">Classes of function</a><a id="Classes-of-function-1"></a><a class="docs-heading-anchor-permalink" href="#Classes-of-function" title="Permalink"></a></h2><p>All time-series functions in <code>TimeDag</code> are of the form of <span>$f$</span> above. Here we identify a few categories of such functions which cover many of the cases of interest.</p><h3 id="No-inputs"><a class="docs-heading-anchor" href="#No-inputs">No inputs</a><a id="No-inputs-1"></a><a class="docs-heading-anchor-permalink" href="#No-inputs" title="Permalink"></a></h3><p>A function <span>$f : \emptyset \rightarrow \mathcal{TS}$</span> can be considered a <em>source</em>. That is, it generates a time-series with no inputs.</p><p>In this case, if <span>$z = f()$</span>, then the implementation <span>$f_b$</span> technically reduces to <span>$z[\delta] = f_b(\delta)$</span>. In principle no state is required, since there is no external information to remember. However, in <em>practice</em> retaining the state term can be useful to increase implementation efficiency.</p><h3 id="Single-input-(map-over-values)"><a class="docs-heading-anchor" href="#Single-input-(map-over-values)">Single input (map over values)</a><a id="Single-input-(map-over-values)-1"></a><a class="docs-heading-anchor-permalink" href="#Single-input-(map-over-values)" title="Permalink"></a></h3><p>Consider an unary <code>-</code> function operating on a time-series; <span>$z = -x$</span>. This is a &quot;boring&quot; time-series operation, in that all times of <span>$z$</span> are identical to those of <span>$x$</span>. The values are determined by <span>$z_i = -x_i\ \forall i$</span>.</p><p>Some unary operators from <code>Base</code>, like <code>Base.:-</code>, have methods on <a href="../reference/fundamentals/#TimeDag.Node"><code>TimeDag.Node</code></a> defined within <code>TimeDag</code>.</p><p>More generally, <a href="../reference/creating_ops/#TimeDag.wrap"><code>wrap</code></a> and <a href="../reference/creating_ops/#TimeDag.wrapb"><code>wrapb</code></a> let you create a time-series function from such an unary function. See <a href="../reference/creating_ops/#Creating-operations">Creating operations</a> for more details.</p><h3 id="Single-input-(lag)"><a class="docs-heading-anchor" href="#Single-input-(lag)">Single input (lag)</a><a id="Single-input-(lag)-1"></a><a class="docs-heading-anchor-permalink" href="#Single-input-(lag)" title="Permalink"></a></h3><p>A <a href="../reference/align/#TimeDag.lag"><code>lag</code></a> is a slightly more complex unary function. Rather than explain it mathematically, a visualisation can help:</p><p><img src="../assets/lag.png" alt="lag"/></p><p>Time is increasing to the right. Each grey arrow indicates that one value is used in computing another — in the case of <a href="../reference/align/#TimeDag.lag"><code>lag</code></a>, the value is simply used directly. Note how, for this function, we never introduce new timestamps — we simply &#39;lag&#39; the previous value onto the next timestamp. </p><p>A related concept is a time-lag, where each knot would be delayed by some fixed period of time <span>$\partial t$</span>:</p><p><img src="../assets/tlag.png" alt="Time lag"/></p><h3 id="Single-input-(cumulative-sum)"><a class="docs-heading-anchor" href="#Single-input-(cumulative-sum)">Single input (cumulative sum)</a><a id="Single-input-(cumulative-sum)-1"></a><a class="docs-heading-anchor-permalink" href="#Single-input-(cumulative-sum)" title="Permalink"></a></h3><p>Similarly to a simple function operation on values, a cumulative sum over time (<a href="../reference/online_windowed/#Base.sum"><code>Base.sum</code></a>) ticks whenever the input ticks. However, this time each value is a function of all preceding knots:</p><p><img src="../assets/sum.png" alt="sum"/></p><h3 id="Alignment"><a class="docs-heading-anchor" href="#Alignment">Alignment</a><a id="Alignment-1"></a><a class="docs-heading-anchor-permalink" href="#Alignment" title="Permalink"></a></h3><p>When considering a function of two or more time-series, a useful special-case is where the output ticks at some subset of the times that all the inputs tick. We consider <em>alignment</em>, which is a selection process with semantics similar (but not identical) to &quot;joins&quot; in database terminology.</p><p>We define three ways of performing alignment. For each one we document the <code>TimeDag</code> constant which should be used in function calls that accept an alignment, and give a graphical interpretation. Each diagram is shown for the case of two inputs; the docstrings describe the general case with more inputs.</p><p>Functions in <code>TimeDag</code> that accept multiple nodes typically default to using <a href="#TimeDag.UNION"><code>UNION</code></a> alignment.</p><h5 id="Union"><a class="docs-heading-anchor" href="#Union">Union</a><a id="Union-1"></a><a class="docs-heading-anchor-permalink" href="#Union" title="Permalink"></a></h5><p>Similar to an &quot;outer join&quot;, with the key difference that we only emit knots once <em>all</em> inputs have started ticking.</p><article class="docstring"><header><a class="docstring-binding" id="TimeDag.UNION" href="#TimeDag.UNION"><code>TimeDag.UNION</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">UNION</code></pre><p>For inputs <code>(A, B, ...)</code>, tick whenever any input ticks so long as all inputs are active.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpgillam/TimeDag.jl/blob/ba8c0e54598a050d6db378a4833261b0e9eee651/src/alignment.jl#L14-L18">source</a></section></article><p><img src="../assets/union_align.png" alt="Union alignment"/></p><h5 id="Intersect"><a class="docs-heading-anchor" href="#Intersect">Intersect</a><a id="Intersect-1"></a><a class="docs-heading-anchor-permalink" href="#Intersect" title="Permalink"></a></h5><p>Tick if and only if both inputs tick. This is identical to an &quot;inner join&quot;.</p><article class="docstring"><header><a class="docstring-binding" id="TimeDag.INTERSECT" href="#TimeDag.INTERSECT"><code>TimeDag.INTERSECT</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">INTERSECT</code></pre><p>For inputs <code>(A, B, ...)</code>, tick whenever all inputs tick simultaneously.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpgillam/TimeDag.jl/blob/ba8c0e54598a050d6db378a4833261b0e9eee651/src/alignment.jl#L21-L25">source</a></section></article><p><img src="../assets/intersect_align.png" alt="Intersect alignment"/></p><h5 id="Left"><a class="docs-heading-anchor" href="#Left">Left</a><a id="Left-1"></a><a class="docs-heading-anchor-permalink" href="#Left" title="Permalink"></a></h5><p>Similar to a &quot;left join&quot;, with the key difference that we only emit knots once <em>all</em> inputs have started ticking.</p><article class="docstring"><header><a class="docstring-binding" id="TimeDag.LEFT" href="#TimeDag.LEFT"><code>TimeDag.LEFT</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">LEFT</code></pre><p>For inputs <code>(A, B, ...)</code>, tick whenever <code>A</code> ticks so long as all inputs are active.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpgillam/TimeDag.jl/blob/ba8c0e54598a050d6db378a4833261b0e9eee651/src/alignment.jl#L7-L11">source</a></section></article><p><img src="../assets/left_align.png" alt="Left alignment"/></p><h4 id="Initial-values"><a class="docs-heading-anchor" href="#Initial-values">Initial values</a><a id="Initial-values-1"></a><a class="docs-heading-anchor-permalink" href="#Initial-values" title="Permalink"></a></h4><p>For the alignments above, it was noted that we have to wait for all inputs to start ticking before the output ticks.</p><p>It is possible to tell <code>TimeDag</code> that a given operation should consider its inputs to have some <em>initial values</em>. This behaves a little like a knot at the start of the evaluation window, however does <em>not</em> result in the creation of an output knot at that time. In the notation above, it is the definition of a value for <span>$x(t_{-})$</span> which isn&#39;t <span>$\oslash$</span>.</p><p>Initial values are set seperately for each input. Most functions of two or more nodes will take an <code>initial_values</code> keyword argument to specify these.</p><p>Some more implementation details on the lower-level functionality that controls this is provided in <a href="../reference/internals/#Alignment-implementation">Alignment implementation</a>.</p><h2 id="Computational-graph"><a class="docs-heading-anchor" href="#Computational-graph">Computational graph</a><a id="Computational-graph-1"></a><a class="docs-heading-anchor-permalink" href="#Computational-graph" title="Permalink"></a></h2><h3 id="Nodes"><a class="docs-heading-anchor" href="#Nodes">Nodes</a><a id="Nodes-1"></a><a class="docs-heading-anchor-permalink" href="#Nodes" title="Permalink"></a></h3><p>So far we have introduced the notion of time-series operations. By working purely with <a href="../reference/fundamentals/#TimeDag.NodeOp"><code>TimeDag.NodeOp</code></a>s, we build up an abstract representation of the computation we want to do. A <a href="../reference/fundamentals/#TimeDag.Node"><code>TimeDag.Node</code></a> contains zero or more input nodes, as well as a <a href="../reference/fundamentals/#TimeDag.NodeOp"><code>TimeDag.NodeOp</code></a> defining how they should be combined.</p><h3 id="Evaluation"><a class="docs-heading-anchor" href="#Evaluation">Evaluation</a><a id="Evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluation" title="Permalink"></a></h3><p>When we wish to evaluate a node over some interval <span>$\delta$</span>, we first evaluate all input nodes over the same interval, recursively. Given all inputs, we can evaluate a particular node using <span>$f_b$</span>, as defined previously. The practicalities of this are discussed further in <a href="../reference/internals/#Advanced-evaluation">Advanced evaluation</a>.</p><h3 id="Subgraph-elimination"><a class="docs-heading-anchor" href="#Subgraph-elimination">Subgraph elimination</a><a id="Subgraph-elimination-1"></a><a class="docs-heading-anchor-permalink" href="#Subgraph-elimination" title="Permalink"></a></h3><p>By using an <a href="../reference/internals/#Identity-map">Identity map</a> we ensure that we never create duplicate nodes. This effectively eliminates the creation of common subgraphs, which means that when performing evaluation we never repeat work.</p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>We currently require that all times are instances of <code>DateTime</code>.</li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a>Diagrams in the alignment section will perhaps be reminiscent of the rope on a <a href="https://en.wikipedia.org/wiki/Chip_log">ship log</a>.</li><li class="footnote" id="footnote-3"><a class="tag is-link" href="#citeref-3">3</a>One is free to choose the open/closed-ness of each bound, however the use of an closed-open interval helps in subsequent analysis.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../examples/">Examples »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.22 on <span class="colophon-date" title="Thursday 11 August 2022 03:26">Thursday 11 August 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
