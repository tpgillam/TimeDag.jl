<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Internals · TimeDag.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://tpgillam.github.io/TimeDag.jl/reference/internals/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.png" alt="TimeDag.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.png" alt="TimeDag.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">TimeDag.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../concepts/">Concepts</a></li><li><a class="tocitem" href="../../examples/">Examples</a></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../fundamentals/">Fundamentals</a></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Node ops</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../align/">Alignment ops</a></li><li><a class="tocitem" href="../arithmetic/">Arithmetic</a></li><li><a class="tocitem" href="../online_windowed/">Online &amp; windowed</a></li><li><a class="tocitem" href="../misc_ops/">Miscellaneous</a></li><li><a class="tocitem" href="../sources/">Sources</a></li></ul></li><li><a class="tocitem" href="../creating_ops/">Creating operations</a></li><li class="is-active"><a class="tocitem" href>Internals</a><ul class="internal"><li><a class="tocitem" href="#Identity-map"><span>Identity map</span></a></li><li><a class="tocitem" href="#Advanced-evaluation"><span>Advanced evaluation</span></a></li><li><a class="tocitem" href="#Alignment-implementation"><span>Alignment implementation</span></a></li><li><a class="tocitem" href="#Maybe"><span>Maybe</span></a></li><li><a class="tocitem" href="#Other"><span>Other</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li class="is-active"><a href>Internals</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Internals</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/tpgillam/TimeDag.jl/blob/main/docs/src/reference/internals.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Internals"><a class="docs-heading-anchor" href="#Internals">Internals</a><a id="Internals-1"></a><a class="docs-heading-anchor-permalink" href="#Internals" title="Permalink"></a></h1><p>This page documents internal, and less commonly-used API. Some of it will be useful for users for more advanced use-cases, like running graphs in production systems. Other parts shouldn&#39;t need to be regularly interacted with, but can be useful to know about.</p><h2 id="Identity-map"><a class="docs-heading-anchor" href="#Identity-map">Identity map</a><a id="Identity-map-1"></a><a class="docs-heading-anchor-permalink" href="#Identity-map" title="Permalink"></a></h2><p>One of the key features of <code>TimeDag</code> is avoiding duplicating work.</p><p>This is primarily achieved by ensuring that we never construct the &#39;same&#39; node twice. By &#39;same&#39;, here we mean two nodes that we can prove will always give the same output.</p><p>One easy-to-handle case is that of a node that has identical parents &amp; op to another. To avoid this, <code>TimeDag</code> maintains a global <a href="https://en.wikipedia.org/wiki/Identity_map_pattern">identity map</a>, of type <a href="#TimeDag.IdentityMap"><code>TimeDag.IdentityMap</code></a>.</p><p>Currently the only implementation of the identity map is <a href="#TimeDag.WeakIdentityMap"><code>TimeDag.WeakIdentityMap</code></a>. This contains weak references to nodes, to ensure that we know about all nodes that currently exist, but don&#39;t unnecessarily prevent nodes from being garbage collected when we no longer want them.</p><p>In practice, all nodes should be constructed indirectly using <a href="../fundamentals/#TimeDag.obtain_node"><code>TimeDag.obtain_node</code></a>.  This will query the <code>global_identity_map()</code>, and only construct a new node if an equivalent one does not already exist.</p><article class="docstring"><header><a class="docstring-binding" id="TimeDag.IdentityMap" href="#TimeDag.IdentityMap"><code>TimeDag.IdentityMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IdentityMap</code></pre><p>An abstract identity map.</p><p>Any implementation of this type needs to implement <a href="#TimeDag.obtain_node!"><code>obtain_node!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpgillam/TimeDag.jl/blob/b208fad7c28f9779b318bdc32f413c00d71931c1/src/identity_map.jl#L33-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeDag.obtain_node!" href="#TimeDag.obtain_node!"><code>TimeDag.obtain_node!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">obtain_node!(id_map::IdentityMap, parents::NTuple{N,Node}, op::NodeOp) -&gt; Node</code></pre><p>If a node with <code>parents</code> and <code>op</code> doesn&#39;t exist inside <code>id_map</code>, create and insert it.</p><p>Return either the new or existing node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpgillam/TimeDag.jl/blob/b208fad7c28f9779b318bdc32f413c00d71931c1/src/identity_map.jl#L122-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeDag.global_identity_map" href="#TimeDag.global_identity_map"><code>TimeDag.global_identity_map</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">global_identity_map() -&gt; IdentityMap</code></pre><p>Get the global IdentityMap instance used in TimeDag.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpgillam/TimeDag.jl/blob/b208fad7c28f9779b318bdc32f413c00d71931c1/src/identity_map.jl#L158-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeDag.WeakNode" href="#TimeDag.WeakNode"><code>TimeDag.WeakNode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WeakNode(parents, op)</code></pre><p>Represent a node-like object that doesn&#39;t hold strong references to its parents.</p><p>This exists purely such that <code>hash</code> and <code>==</code> <em>do</em> allow multiple instances of <code>WeakNode</code> to compare equal if they have the same <code>parents</code> and <code>op</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpgillam/TimeDag.jl/blob/b208fad7c28f9779b318bdc32f413c00d71931c1/src/identity_map.jl#L12-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeDag.WeakIdentityMap" href="#TimeDag.WeakIdentityMap"><code>TimeDag.WeakIdentityMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WeakIdentityMap</code></pre><p>Represent a collection of nodes which doesn&#39;t hold strong references to any nodes.</p><p>This is useful, as it allows the existence of this cache to be somewhat transparent to the user, and they only have to care about holding on to references for nodes that they care about.</p><p>This structure contains nodes, but also node weak nodes – these allow us to determine whether we ought to create a given node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpgillam/TimeDag.jl/blob/b208fad7c28f9779b318bdc32f413c00d71931c1/src/identity_map.jl#L42-L53">source</a></section></article><h2 id="Advanced-evaluation"><a class="docs-heading-anchor" href="#Advanced-evaluation">Advanced evaluation</a><a id="Advanced-evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-evaluation" title="Permalink"></a></h2><p>This section goes into more detail about how evaluation works.  We explain evaluation state, and discuss how to use the API in a <a href="#Live-system">Live system</a>.</p><h3 id="Evaluation-state"><a class="docs-heading-anchor" href="#Evaluation-state">Evaluation state</a><a id="Evaluation-state-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluation-state" title="Permalink"></a></h3><p>Recall from the discussion in <a href="../../concepts/#Concepts">Concepts</a> that we have the concept of <a href="../../concepts/#Explicit-state">Explicit state</a>. For a particular node, this state will be a subtype of <a href="#TimeDag.NodeEvaluationState"><code>TimeDag.NodeEvaluationState</code></a>. For consistency, all nodes have an evaluation state — for nodes that are fundamentally stateless, we use <a href="#TimeDag.EMPTY_NODE_STATE"><code>TimeDag.EMPTY_NODE_STATE</code></a>.</p><p>A fresh evaluation state is created by a call to <a href="#TimeDag.create_evaluation_state"><code>TimeDag.create_evaluation_state</code></a>. When creating a new <a href="../fundamentals/#TimeDag.NodeOp"><code>TimeDag.NodeOp</code></a>, a new method of this function should be defined to return the appropriate state. The state is subsequently mutated in calls <a href="#TimeDag.run_node!"><code>TimeDag.run_node!</code></a>, to reflect any changes induced over the time interval.</p><article class="docstring"><header><a class="docstring-binding" id="TimeDag.NodeEvaluationState" href="#TimeDag.NodeEvaluationState"><code>TimeDag.NodeEvaluationState</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type NodeEvaluationState end</code></pre><p>Represents any and all state that a node must retain between evaluating batches.</p><p>Instances of subtypes of <code>NodeEvaluationState</code> are given to <a href="#TimeDag.run_node!"><code>run_node!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpgillam/TimeDag.jl/blob/b208fad7c28f9779b318bdc32f413c00d71931c1/src/core.jl#L47-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeDag.EmptyNodeEvaluationState" href="#TimeDag.EmptyNodeEvaluationState"><code>TimeDag.EmptyNodeEvaluationState</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EmptyNodeEvaluationState()</code></pre><p>A <a href="#TimeDag.NodeEvaluationState"><code>NodeEvaluationState</code></a> which has no content, to be used by non-stateful nodes.</p><p>In practice, the common instance <a href="#TimeDag.EMPTY_NODE_STATE"><code>TimeDag.EMPTY_NODE_STATE</code></a> can be used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpgillam/TimeDag.jl/blob/b208fad7c28f9779b318bdc32f413c00d71931c1/src/core.jl#L56-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeDag.EMPTY_NODE_STATE" href="#TimeDag.EMPTY_NODE_STATE"><code>TimeDag.EMPTY_NODE_STATE</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">const EMPTY_NODE_STATE</code></pre><p>A singleton instance of <a href="#TimeDag.EmptyNodeEvaluationState"><code>TimeDag.EmptyNodeEvaluationState</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpgillam/TimeDag.jl/blob/b208fad7c28f9779b318bdc32f413c00d71931c1/src/core.jl#L66-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeDag.create_evaluation_state" href="#TimeDag.create_evaluation_state"><code>TimeDag.create_evaluation_state</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">create_evaluation_state(node::Node) -&gt; NodeEvaluationState
create_evaluation_state(parents, node::NodeOp) -&gt; NodeEvaluationState</code></pre><p>Create an empty evaluation state for the given node, when starting evaluation at the specified time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpgillam/TimeDag.jl/blob/b208fad7c28f9779b318bdc32f413c00d71931c1/src/core.jl#L80-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeDag.stateless" href="#TimeDag.stateless"><code>TimeDag.stateless</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">stateless(node) -&gt; Bool
stateless(op) -&gt; Bool</code></pre><p>Returns true iff <code>op</code> can be assumed to be stateless; that is, if the node evaluation state is <a href="#TimeDag.EMPTY_NODE_STATE"><code>TimeDag.EMPTY_NODE_STATE</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpgillam/TimeDag.jl/blob/b208fad7c28f9779b318bdc32f413c00d71931c1/src/core.jl#L120-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeDag.run_node!" href="#TimeDag.run_node!"><code>TimeDag.run_node!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">run_node!(
    op::NodeOp{T},
    state::NodeEvaluationState,
    time_start::DateTime,
    time_end::DateTime,
    input_blocks::Block...
) -&gt; Block{T}</code></pre><p>Evaluate the given node from <code>time_start</code> until <code>time_end</code>, with the initial <code>state</code>. Zero or more blocks will be passed as an input; these correspond to the parents of a node, and are passed in the same order as that returned by <code>parents(node)</code>.</p><p>We return a new <a href="../fundamentals/#TimeDag.Block"><code>Block</code></a> of output knots from this node.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The implementer of <code>run_node!</code> must ensure:</p><ul><li><strong>No future peeking</strong> occurs: i.e. that no output knot is dependent on input knots   that occur subsequently.</li><li><strong>Correct time range</strong>: all output timestamps must be in the interval   <code>[time_start, time_end)</code>.</li><li><strong>Consistency</strong>: Calling <code>run_node!</code> over a single interval should give the same   result as calling it multiple times over a decomposition of that same interval.   This ensures that the value returned by <a href="../fundamentals/#TimeDag.evaluate"><code>evaluate</code></a> is invariant to the   <code>batch_interval</code> kwarg provided.</li><li><strong>Determinism</strong>: <code>run_node!</code> should <em>always</em> be fully deterministic. If a   pseudo-random number generator is required, it should be held on the evaluation   state.</li></ul></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpgillam/TimeDag.jl/blob/b208fad7c28f9779b318bdc32f413c00d71931c1/src/core.jl#L89-L117">source</a></section></article><p>When an evaluation is performed, we need to save the state of all the nodes in the graph. We package this into an <a href="#TimeDag.EvaluationState"><code>TimeDag.EvaluationState</code></a> instance. This object also retains the blocks from the nodes in whose output we&#39;re interested.</p><article class="docstring"><header><a class="docstring-binding" id="TimeDag.EvaluationState" href="#TimeDag.EvaluationState"><code>TimeDag.EvaluationState</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EvaluationState</code></pre><p>All state necessary for the evaluation of some nodes.</p><p>This should be created with <a href="#TimeDag.start_at"><code>start_at</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>ordered_node_to_children::OrderedDict{Node,Set{Node}}</code>: a map from every node which we   need to run, to its children. The ordering of the elements is such that, if evaluated in   this order, all dependencies will be evaluated before they are required.</li><li><code>node_to_state::IdDict{Node,NodeEvaluationState}</code>: maintain the state for every node   being evaluated.</li><li><code>current_time::DateTime</code>: the time to which this state corresponds.</li><li><code>evaluated_node_to_blocks::IdDict{Node,Vector{Block}}</code>: the output blocks that we care   about.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpgillam/TimeDag.jl/blob/b208fad7c28f9779b318bdc32f413c00d71931c1/src/evaluation.jl#L1-L17">source</a></section></article><h3 id="Deconstructing-evaluation"><a class="docs-heading-anchor" href="#Deconstructing-evaluation">Deconstructing evaluation</a><a id="Deconstructing-evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Deconstructing-evaluation" title="Permalink"></a></h3><p>Whilst <a href="../fundamentals/#TimeDag.evaluate"><code>evaluate</code></a> is the primary API for <code>TimeDag</code>, it is in fact a thin wrapper around a lower level API. Roughly, the steps involved are:</p><ol><li>Call <a href="#TimeDag.start_at"><code>TimeDag.start_at</code></a> to create a new <a href="#TimeDag.EvaluationState"><code>TimeDag.EvaluationState</code></a> for a collection of nodes.  This will work out all the ancestors of the given nodes that also need to be evaluated.</li><li>Perform one or more calls to <a href="#TimeDag.evaluate_until!"><code>TimeDag.evaluate_until!</code></a>, depending on the batch interval.  Each call will update the evaluation state.  Interenally, this calls <a href="#TimeDag.run_node!"><code>TimeDag.run_node!</code></a> for every ancestor node.</li><li>Once the end of the evaluation interval has been reached, we extract the blocks for the nodes of interest from the evaluation state.  These are concatenated and returned to the user.</li></ol><article class="docstring"><header><a class="docstring-binding" id="TimeDag.start_at" href="#TimeDag.start_at"><code>TimeDag.start_at</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">start_at(nodes, time_start::DateTime) -&gt; EvaluationState</code></pre><p>Create a sufficient <a href="#TimeDag.EvaluationState"><code>EvaluationState</code></a> for the evaluation of <code>nodes</code>.</p><p>Internally, this will determine the subgraph that needs evaluating, i.e. all the ancestors of <code>nodes</code>, and create a <a href="#TimeDag.NodeEvaluationState"><code>NodeEvaluationState</code></a> for each of these.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpgillam/TimeDag.jl/blob/b208fad7c28f9779b318bdc32f413c00d71931c1/src/evaluation.jl#L47-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeDag.evaluate_until!" href="#TimeDag.evaluate_until!"><code>TimeDag.evaluate_until!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">evaluate_until!(state::EvaluationState, time_end::DateTime)</code></pre><p>Update the evaluation state by performing the evalution for each node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpgillam/TimeDag.jl/blob/b208fad7c28f9779b318bdc32f413c00d71931c1/src/evaluation.jl#L77-L81">source</a></section></article><h4 id="Live-system"><a class="docs-heading-anchor" href="#Live-system">Live system</a><a id="Live-system-1"></a><a class="docs-heading-anchor-permalink" href="#Live-system" title="Permalink"></a></h4><p>Consider the case where some history of data is available, say in a database, and new data is added continually, e.g. as it is recorded from a sensor. Suppose we have built a <code>TimeDag</code> graph representing the computation we wish to perform on this data. We can perform the following steps:</p><ol><li>Initialise the state with <a href="#TimeDag.start_at"><code>TimeDag.start_at</code></a>.</li><li>Initialise the model with one (or more) calls to <a href="#TimeDag.evaluate_until!"><code>TimeDag.evaluate_until!</code></a>.  This is used to pull through historical data, e.g. to initialise stateful nodes like moving averages.</li><li>In real time, poll for new data with repeated calls to <a href="#TimeDag.evaluate_until!"><code>TimeDag.evaluate_until!</code></a></li></ol><p>The performance of this setup is naturally dependent upon the complexity of the model being evaluated. However, if models are appropriately designed to have efficient online updates, then the underlying overhead of <code>TimeDag</code> is sufficiently small for this to be usable with latencies of down to O(milliseconds).</p><pre><code class="language-julia hljs"># Some arbitrary data source - here just use random numbers.
x = rand(pulse(Second(1)))

# Compute a rolling mean and standard deviation.
# Corresponds to 24-hour rolling windows, given one data point per second.
n1, n2 = mean(x, 86400), std(x, 86400)

# Initialise state over a long history.
state = TimeDag.start_at([n1, n2], DateTime(2019))
state = TimeDag.evaluate_until!(state, DateTime(2020))

# Simulate an incremental update over a few hours.
@time state = TimeDag.evaluate_until!(state, DateTime(2020, 1, 1, 3))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">  0.007417 seconds (75.24 k allocations: 2.387 MiB)</code></pre><p>Note that this approach is unlikely to be suitable for lower latency applications (e.g. microseconds). For that case, one may benefit from a &quot;push mode&quot; evaluation, where new data are pushed onto the graph, and only affected nodes are re-evaluated. Such a feature isn&#39;t currently planned.</p><h3 id="Scheduling"><a class="docs-heading-anchor" href="#Scheduling">Scheduling</a><a id="Scheduling-1"></a><a class="docs-heading-anchor-permalink" href="#Scheduling" title="Permalink"></a></h3><p><code>TimeDag</code> currently runs all nodes in a single thread, however this is subject to change in the future.</p><h2 id="Alignment-implementation"><a class="docs-heading-anchor" href="#Alignment-implementation">Alignment implementation</a><a id="Alignment-implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Alignment-implementation" title="Permalink"></a></h2><p>If we want to define a new op that follows alignment semantics, it should derive from one of the following types.</p><article class="docstring"><header><a class="docstring-binding" id="TimeDag.UnaryNodeOp" href="#TimeDag.UnaryNodeOp"><code>TimeDag.UnaryNodeOp</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">UnaryNodeOp{T} &lt;: NodeOp{T}</code></pre><p>An abstract type representing a node op with a single parent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpgillam/TimeDag.jl/blob/b208fad7c28f9779b318bdc32f413c00d71931c1/src/alignment.jl#L31-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeDag.BinaryNodeOp" href="#TimeDag.BinaryNodeOp"><code>TimeDag.BinaryNodeOp</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BinaryNodeOp{T,A&lt;:Alignment} &lt;: NodeOp{T}</code></pre><p>An abstract type representing a node op with two parents, and using alignment <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpgillam/TimeDag.jl/blob/b208fad7c28f9779b318bdc32f413c00d71931c1/src/alignment.jl#L38-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeDag.NaryNodeOp" href="#TimeDag.NaryNodeOp"><code>TimeDag.NaryNodeOp</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NaryNodeOp{N,T,A&lt;:Alignment} &lt;: NodeOp{T}</code></pre><p>An abstract type representing a node op with <code>N</code> parents, and using alignment <code>A</code>.</p><p>This type should be avoided for <code>N &lt; 3</code>, since in these cases it would be more appropriate to use either <a href="#TimeDag.UnaryNodeOp"><code>TimeDag.UnaryNodeOp</code></a> or <a href="#TimeDag.BinaryNodeOp"><code>TimeDag.BinaryNodeOp</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpgillam/TimeDag.jl/blob/b208fad7c28f9779b318bdc32f413c00d71931c1/src/alignment.jl#L45-L52">source</a></section></article><p>Instead of implementing <a href="#TimeDag.run_node!"><code>TimeDag.run_node!</code></a> directly, one instead implements some of the following functions. The exact alignment logic is then encapsulated, and doesn&#39;t need to be dealt with directly.</p><article class="docstring"><header><a class="docstring-binding" id="TimeDag.operator!" href="#TimeDag.operator!"><code>TimeDag.operator!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">operator!(op::UnaryNodeOp{T}, (state,), (time,) x) -&gt; T / Maybe{T}
operator!(op::BinaryNodeOp{T}, (state,), (time,) x, y) -&gt; T / Maybe{T}
operator!(op::NaryNodeOp{N,T}, (state,), (time,) x, y, z...) -&gt; T / Maybe{T}</code></pre><p>Perform the operation for this node.</p><p>When defining a method of this for a new op, follow these rules:</p><ul><li><code>state</code> should be omitted iff <a href="#TimeDag.stateless_operator"><code>TimeDag.stateless_operator</code></a>.</li><li><code>time</code> should be omitted iff <a href="#TimeDag.time_agnostic"><code>TimeDag.time_agnostic</code></a>.</li><li>All values <code>x, y, z...</code> should be omittted iff <a href="#TimeDag.value_agnostic"><code>TimeDag.value_agnostic</code></a>.</li></ul><p>For stateful operations, this operator should mutate <code>state</code> as required.</p><p>The return value <code>out</code> should be of type <code>T</code> iff <a href="#TimeDag.always_ticks"><code>TimeDag.always_ticks</code></a> is true, otherwise it should be of type <a href="#TimeDag.Maybe"><code>TimeDag.Maybe</code></a><code>{T}</code>.</p><p>If <code>out &lt;: Maybe{T}</code>, and has <code>!valid(out)</code>, this indicates that we do not wish to emit a knot at this time, and it will be skipped. Otherwise, <code>value(out)</code> will be used as the output value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpgillam/TimeDag.jl/blob/b208fad7c28f9779b318bdc32f413c00d71931c1/src/alignment.jl#L144-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeDag.always_ticks" href="#TimeDag.always_ticks"><code>TimeDag.always_ticks</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">always_ticks(node) -&gt; Bool
always_ticks(op) -&gt; Bool</code></pre><p>Returns true iff the return value from <code>operator!</code> can be assumed to always be valid.</p><p>If <code>true</code>, <code>operator!(::Node{T}, ...)</code> should return a <code>T</code>. If <code>false</code>, <code>operator!(::Node{T}, ...)</code> should return a <code>Maybe{T}</code>.</p><p>Note, that for sensible performance characteristics, this should be knowable from <code>typeof(op)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpgillam/TimeDag.jl/blob/b208fad7c28f9779b318bdc32f413c00d71931c1/src/alignment.jl#L167-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeDag.stateless_operator" href="#TimeDag.stateless_operator"><code>TimeDag.stateless_operator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">stateless_operator(node) -&gt; Bool
stateless_operator(op) -&gt; Bool</code></pre><p>Returns true iff <code>operator(op, ...)</code> would never look at or modify the evaluation state.</p><p>If this returns true, <code>create_operator_evaluation_state</code> will not be used.</p><p>Note that if an <code>op</code> has <code>stateless(op)</code> returning true, then it necessarily should also return true here. The default implementation is to return <code>stateless(op)</code>, meaning that if one is creating a node that is fully stateless, one need only define <code>stateless</code>.</p><p>For optimal performance, this should be knowable from the type of <code>op</code> alone.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpgillam/TimeDag.jl/blob/b208fad7c28f9779b318bdc32f413c00d71931c1/src/alignment.jl#L182-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeDag.time_agnostic" href="#TimeDag.time_agnostic"><code>TimeDag.time_agnostic</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">time_agnostic(node) -&gt; Bool
time_agnostic(op) -&gt; Bool</code></pre><p>Returns true iff <code>op</code> does not care about the time of the input knot(s).</p><p>For optimal performance, this should be knowable from the type of <code>op</code> alone.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpgillam/TimeDag.jl/blob/b208fad7c28f9779b318bdc32f413c00d71931c1/src/alignment.jl#L199-L206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeDag.value_agnostic" href="#TimeDag.value_agnostic"><code>TimeDag.value_agnostic</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">value_agnostic(node) -&gt; Bool
value_agnostic(op) -&gt; Bool</code></pre><p>Returns true iff <code>op</code> does not care about the value(s) of the input knot(s).</p><p>For optimal performance, this should be knowable from the type of <code>op</code> alone.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpgillam/TimeDag.jl/blob/b208fad7c28f9779b318bdc32f413c00d71931c1/src/alignment.jl#L210-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeDag.has_initial_values" href="#TimeDag.has_initial_values"><code>TimeDag.has_initial_values</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">has_initial_values(op) -&gt; Bool</code></pre><p>If this returns true, it indicates that initial values for the <code>op</code>&#39;s parents are specified.</p><p>See the documentation on <a href="../../concepts/#Initial-values">Initial values</a> for further information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpgillam/TimeDag.jl/blob/b208fad7c28f9779b318bdc32f413c00d71931c1/src/alignment.jl#L232-L238">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeDag.initial_left" href="#TimeDag.initial_left"><code>TimeDag.initial_left</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">initial_left(op::BinaryNodeOp) -&gt; L</code></pre><p>Specify the initial value to use for the first parent of the given <code>op</code>.</p><p>Needs to be defined if <a href="#TimeDag.has_initial_values"><code>has_initial_values</code></a> returns true, and alignment is <a href="../../concepts/#TimeDag.UNION"><code>UNION</code></a>. For other alignments it is not required.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpgillam/TimeDag.jl/blob/b208fad7c28f9779b318bdc32f413c00d71931c1/src/alignment.jl#L242-L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeDag.initial_right" href="#TimeDag.initial_right"><code>TimeDag.initial_right</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">initial_right(op::BinaryNodeOp) -&gt; R</code></pre><p>Specify the initial value to use for the second parent of the given <code>op</code>.</p><p>Needs to be defined if <code>has_initial_values(op)</code> returns true, and alignment is <a href="../../concepts/#TimeDag.UNION"><code>UNION</code></a> or <a href="../../concepts/#TimeDag.LEFT"><code>LEFT</code></a>. For <a href="../../concepts/#TimeDag.INTERSECT"><code>INTERSECT</code></a> alignment it is not required.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpgillam/TimeDag.jl/blob/b208fad7c28f9779b318bdc32f413c00d71931c1/src/alignment.jl#L252-L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeDag.initial_values" href="#TimeDag.initial_values"><code>TimeDag.initial_values</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">initial_values(op::NaryNodeOp) -&gt; Tuple</code></pre><p>Specify the initial values to use for all parents of the given <code>op</code>.</p><p>Needs to be defined for nary ops for which <a href="#TimeDag.has_initial_values"><code>has_initial_values</code></a> returns true.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpgillam/TimeDag.jl/blob/b208fad7c28f9779b318bdc32f413c00d71931c1/src/alignment.jl#L262-L268">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeDag.create_operator_evaluation_state" href="#TimeDag.create_operator_evaluation_state"><code>TimeDag.create_operator_evaluation_state</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">create_operator_evaluation_state(parents, op::NodeOp) -&gt; NodeEvaluationState</code></pre><p>Create an empty evaluation state for the given node, when starting evaluation at the specified time.</p><p>Note that this is state that will be passed to <code>operator</code>. The overall node may additionally wrap this state with further state, if this is necessary for e.g. alignment.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpgillam/TimeDag.jl/blob/b208fad7c28f9779b318bdc32f413c00d71931c1/src/alignment.jl#L221-L229">source</a></section></article><p>For simple cases, the following node ops can be useful.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Rather than using the structures below directly, you probably want to use <a href="../creating_ops/#TimeDag.apply"><code>TimeDag.apply</code></a>, <a href="../creating_ops/#TimeDag.wrap"><code>wrap</code></a>, or <a href="../creating_ops/#TimeDag.wrapb"><code>wrapb</code></a>.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="TimeDag.SimpleUnary" href="#TimeDag.SimpleUnary"><code>TimeDag.SimpleUnary</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SimpleUnary{f,TimeAgnostic,T}</code></pre><p>Represents a stateless unary operator that will always emit a value.</p><p>The value of the <code>TimeAgnostic</code> type parmater is coupled to <a href="#TimeDag.time_agnostic"><code>time_agnostic</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpgillam/TimeDag.jl/blob/b208fad7c28f9779b318bdc32f413c00d71931c1/src/ops/common.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeDag.SimpleBinary" href="#TimeDag.SimpleBinary"><code>TimeDag.SimpleBinary</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SimpleBinary{f,TimeAgnostic,T,A}</code></pre><p>Represents a stateless binary operator that will always emit a value.</p><p>The value of the <code>TimeAgnostic</code> type parmater is coupled to <a href="#TimeDag.time_agnostic"><code>time_agnostic</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpgillam/TimeDag.jl/blob/b208fad7c28f9779b318bdc32f413c00d71931c1/src/ops/common.jl#L17-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeDag.SimpleBinaryUnionInitial" href="#TimeDag.SimpleBinaryUnionInitial"><code>TimeDag.SimpleBinaryUnionInitial</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SimpleBinaryUnionInitial{f,TimeAgnostic,T,L,R}</code></pre><p>Represents a stateless binary operator that will always emit a value.</p><p>The value of the <code>TimeAgnostic</code> type parmater is coupled to <a href="#TimeDag.time_agnostic"><code>time_agnostic</code></a>.</p><p>Unlike <a href="#TimeDag.SimpleBinary"><code>SimpleBinary</code></a>, this also contains initial values for its parent nodes. See <a href="../../concepts/#Initial-values">Initial values</a> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpgillam/TimeDag.jl/blob/b208fad7c28f9779b318bdc32f413c00d71931c1/src/ops/common.jl#L33-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeDag.SimpleBinaryLeftInitial" href="#TimeDag.SimpleBinaryLeftInitial"><code>TimeDag.SimpleBinaryLeftInitial</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SimpleBinaryLeftInitial{f,T,R}</code></pre><p>Represents a stateless binary operator that will always emit a value.</p><p>The value of the <code>TimeAgnostic</code> type parmater is coupled to <a href="#TimeDag.time_agnostic"><code>time_agnostic</code></a>.</p><p>Unlike <a href="#TimeDag.SimpleBinary"><code>SimpleBinary</code></a>, this also contains initial values for its right parent. See <a href="../../concepts/#Initial-values">Initial values</a> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpgillam/TimeDag.jl/blob/b208fad7c28f9779b318bdc32f413c00d71931c1/src/ops/common.jl#L58-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeDag.SimpleNary" href="#TimeDag.SimpleNary"><code>TimeDag.SimpleNary</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SimpleNary{f,TimeAgnostic,N,T,A}</code></pre><p>Represents a stateless <code>N</code>ary operator that will always emit a value.</p><p>The value of the <code>TimeAgnostic</code> type parmater is coupled to <a href="#TimeDag.time_agnostic"><code>time_agnostic</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpgillam/TimeDag.jl/blob/b208fad7c28f9779b318bdc32f413c00d71931c1/src/ops/common.jl#L81-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeDag.SimpleNaryInitial" href="#TimeDag.SimpleNaryInitial"><code>TimeDag.SimpleNaryInitial</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SimpleNaryInitial{f,TimeAgnostic,N,T,A,Types}</code></pre><p>Represents a stateless binary operator that will always emit a value.</p><p>The value of the <code>TimeAgnostic</code> type parmater is coupled to <a href="#TimeDag.time_agnostic"><code>time_agnostic</code></a>.</p><p>Unlike <a href="#TimeDag.SimpleNary"><code>SimpleNary</code></a>, this also contains initial values. See <a href="../../concepts/#Initial-values">Initial values</a> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpgillam/TimeDag.jl/blob/b208fad7c28f9779b318bdc32f413c00d71931c1/src/ops/common.jl#L97-L106">source</a></section></article><h2 id="Maybe"><a class="docs-heading-anchor" href="#Maybe">Maybe</a><a id="Maybe-1"></a><a class="docs-heading-anchor-permalink" href="#Maybe" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="TimeDag.Maybe" href="#TimeDag.Maybe"><code>TimeDag.Maybe</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Maybe{T}()
Maybe(value::T)</code></pre><p>A structure which can hold a value of type <code>T</code>, or represent the absence of a value.</p><p>The API is optimised for speed over memory usage, by allowing a function that may otherwise return <code>Union{T, Nothing}</code> to instead always return <code>Maybe{T}</code>, and hence be type-stable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpgillam/TimeDag.jl/blob/b208fad7c28f9779b318bdc32f413c00d71931c1/src/maybe.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeDag.valid" href="#TimeDag.valid"><code>TimeDag.valid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">valid(x::Maybe) -&gt; Bool</code></pre><p>Return true iff <code>x</code> holds a value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpgillam/TimeDag.jl/blob/b208fad7c28f9779b318bdc32f413c00d71931c1/src/maybe.jl#L22-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeDag.value" href="#TimeDag.value"><code>TimeDag.value</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">value(x::Maybe{T}) -&gt; T</code></pre><p>Returns the value stored in <code>x</code>, or throws an <code>ArgumentError</code> if <code>!valid(x)</code>.</p><p>Note that, in a tight loop, it is preferable to use a combination of calls to <code>valid</code> and <code>unsafe_value</code>, as it will generate more optimal code.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpgillam/TimeDag.jl/blob/b208fad7c28f9779b318bdc32f413c00d71931c1/src/maybe.jl#L29-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeDag.unsafe_value" href="#TimeDag.unsafe_value"><code>TimeDag.unsafe_value</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unsafe_value(x::Maybe{T}) -&gt; T</code></pre><p>Returns the value stored in <code>x</code>.</p><p>It is &quot;unsafe&quot; when <code>!valid(x)</code>, in that the return value of this function is undefined. If <code>T</code> is a reference type, calling this function will result in an <code>UndefRefError</code> being thrown.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpgillam/TimeDag.jl/blob/b208fad7c28f9779b318bdc32f413c00d71931c1/src/maybe.jl#L39-L47">source</a></section></article><h2 id="Other"><a class="docs-heading-anchor" href="#Other">Other</a><a id="Other-1"></a><a class="docs-heading-anchor-permalink" href="#Other" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="TimeDag.output_type" href="#TimeDag.output_type"><code>TimeDag.output_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">output_type(f, arg_types...)</code></pre><p>Return the output type of the specified function. Tries to be fast where possible.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This uses <code>Base.promote_op</code>, which is noted to be fragile. The problem is that whilst one might hope that <code>typeof(f(map(oneunit, arg_types)...))</code> could be used, in practice there are a lot of types which do not define <code>oneunit</code>.</p><p>Ultimately this represents a tension between the desire of <code>TimeDag</code> to know the <em>type</em> of the output of a node without yet knowing the concrete values of the input type.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpgillam/TimeDag.jl/blob/b208fad7c28f9779b318bdc32f413c00d71931c1/src/output_type.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeDag.duplicate" href="#TimeDag.duplicate"><code>TimeDag.duplicate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">duplicate(x)</code></pre><p>Return an object that is equal to <code>x</code>, but fully independent of it.</p><p>Note that for any parts of <code>x</code> that <code>TimeDag</code> considers to be immutable (e.g. <code>Block</code>s), this can return the identical object.</p><p>Conceptually this is otherwise very similar to <code>deepcopy(x)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpgillam/TimeDag.jl/blob/b208fad7c28f9779b318bdc32f413c00d71931c1/src/core.jl#L130-L139">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../creating_ops/">« Creating operations</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Wednesday 2 November 2022 04:04">Wednesday 2 November 2022</span>. Using Julia version 1.8.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
