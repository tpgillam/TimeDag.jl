var documenterSearchIndex = {"docs":
[{"location":"reference/creating_ops/#Creating-operations","page":"Creating operations","title":"Creating operations","text":"","category":"section"},{"location":"reference/creating_ops/","page":"Creating operations","title":"Creating operations","text":"Sometimes the operations contained in TimeDag will not be sufficient. This document explains how new operations can be created.","category":"page"},{"location":"reference/creating_ops/#Standard-alignment-behaviour","page":"Creating operations","title":"Standard alignment behaviour","text":"","category":"section"},{"location":"reference/creating_ops/","page":"Creating operations","title":"Creating operations","text":"In many cases, one wishes to write an op that specifies how to process one or more input values, whilst using default alignment semantics.  In this case, one should use TimeDag.apply, wrap or wrapb.","category":"page"},{"location":"reference/creating_ops/","page":"Creating operations","title":"Creating operations","text":"TimeDag.apply\nwrap\nwrapb","category":"page"},{"location":"reference/creating_ops/#TimeDag.apply","page":"Creating operations","title":"TimeDag.apply","text":"apply(f::Function, x; out_type=nothing, time_agnostic=true)\napply(\n    f::Function, x, y[, z, ..., alignment=DEFAULT_ALIGNMENT];\n    out_type=nothing, time_agnostic=true, initial_values=nothing\n)\n\nObtain a node with values constructed by applying the pure function f to the input values.\n\nIff time_agnostic is false, f will be passed the time of the current knot as the first argument, in addition to any values.\n\nWith more than one nodal argument, alignment will be performed. In this case, the alignment argument can be specified as one of INTERSECT, LEFT or UNION. If unspecified, DEFAULT_ALIGNMENT will be used.\n\nInternally this will infer the output type of f applied to the arguments, and will also ensure that subgraph elimination occurs when possible.\n\nIf out_type is not specified, we attempt to infer the value type of the resulting node automatically, using output_type. Alternatively, if out_type is given as anything other than nothing, it will be used instead.\n\n\n\n\n\n","category":"function"},{"location":"reference/creating_ops/#TimeDag.wrap","page":"Creating operations","title":"TimeDag.wrap","text":"wrap(f::Function; time_agnostic=true)\n\nReturn a callable object that acts on nodes, and returns a node.\n\nIt is assumed that f is stateless (this will therefore not work with closures). We also assume that we will always emit a knot when the alignment semantics say we should — thus f must always return a valid output value.\n\nIff time_agnostic is false, f will be passed the time of the current knot as the first argument, followed by the value of every input.\n\nIf the object is called with more than one node, alignment will be performed. If an alignment other than the default should be used, provide it as the final argument.\n\nInternally this will call TimeDag.apply(f, args...; kwargs...); see there for further details.\n\n\n\n\n\n","category":"function"},{"location":"reference/creating_ops/#TimeDag.wrapb","page":"Creating operations","title":"TimeDag.wrapb","text":"wrapb(f::Function; time_agnostic=true)\n\nwrapb is like wrap, however f will be broadcasted over all input values.\n\n\n\n\n\n","category":"function"},{"location":"reference/creating_ops/#Creating-sources","page":"Creating operations","title":"Creating sources","text":"","category":"section"},{"location":"reference/creating_ops/","page":"Creating operations","title":"Creating operations","text":"In order to create a source — i.e. an op with zero inputs — one should use the Low-level API.","category":"page"},{"location":"reference/creating_ops/#Low-level-API","page":"Creating operations","title":"Low-level API","text":"","category":"section"},{"location":"reference/creating_ops/","page":"Creating operations","title":"Creating operations","text":"The most general way to create an op is to create a structure that inherits from TimeDag.NodeOp, and implement TimeDag.run_node!. One must use this to implement source nodes, but in other cases it is typically preferable to use Standard alignment behaviour. This is because there are number of rules that must be adhered to when implementing TimeDag.run_node!, as noted in its docstring. ","category":"page"},{"location":"reference/creating_ops/#Example:-stateless-source","page":"Creating operations","title":"Example: stateless source","text":"","category":"section"},{"location":"reference/creating_ops/","page":"Creating operations","title":"Creating operations","text":"Here is stateless source node, which is effectively a simplified iterdates:","category":"page"},{"location":"reference/creating_ops/","page":"Creating operations","title":"Creating operations","text":"struct MySource <: TimeDag.NodeOp{Int64} end\n\n# Indicate that our source doesn't have any evaluation state.\nTimeDag.stateless(::MySource) = true\n\nfunction TimeDag.run_node!(\n    ::MySource, \n    ::TimeDag.EmptyNodeEvaluationState, \n    time_start::DateTime, \n    time_end::DateTime,\n)\n    # We must return a Block with data covering the interval [time_start, time_end).\n   \n    # Here we define a node which ticks every day at midnight.\n    t1 = Date(time_start) + Time(0)\n    t1 = t1 < time_start ? t1 + Day(1) : t1\n\n    # Figure out the last time to emit.\n    t2 = Date(time_end) + Time(0)\n    t2 = t2 >= time_end ? t2 - Day(1) : t2\n\n    # For no particular reason, we \n    times = t1:Day(1):t2\n    values = ones(length(times))\n    return Block(times, values)\nend","category":"page"},{"location":"concepts/#Concepts","page":"Concepts","title":"Concepts","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"This document explains some key concepts and terminology.","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"We begin with a mathematical framework for expressing time-series operations. This is then used to form analogies with code in TimeDag, and motivate some of the design decisions.","category":"page"},{"location":"concepts/#Time-series","page":"Concepts","title":"Time-series","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"We define a time-series x in mathcalTS subset mathcalT times mathcalX to be an ordered sequence of N time-value pairs:","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"beginaligned\nx   = (t_i x_i)  i in 1 N\nt_i in mathcalT_x forall i quad mathcalT_x = t_1 infty) subset mathcalT\nx_i in mathcalX forall i\nt_i  t_i-1 forall i\nendaligned","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Here we use mathcalT to denote the type of time.[1] We only require that there is a total order on mathcalT — but thinking about it as a real number is a good analogy. We also, somewhat sloppily, identify infty with max mathcalT.","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"[1]: We currently require that all times are instances of DateTime.","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"This restriction may be relaxed in the future.","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Colloquially, we will refer to a time-value pair as a knot.[2]","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"[2]: Diagrams in the alignment section will perhaps be reminiscent of the rope on a ship log.","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"mathcalT_x is the semi-infinite interval bounded below by the time of the first knot in x.","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"We define the TimeDag.value_type of x to be the set mathcalX above, and in practice this can be any Julia type.","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"TimeDag primarily represents a time-series as a TimeDag.Node.  It also stores time-series data in memory in the Block type.","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Here is a visualisation of a time-series x:","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"(Image: A time series)","category":"page"},{"location":"concepts/#Functional-interpretation","page":"Concepts","title":"Functional interpretation","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"We can also consider x to be a function, x  mathcalT_x rightarrow mathcalX. This is defined x(t) = max_i x_i textrmst t_i leq t.","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Informally, this means that whenever we observe a value x_i, the 'value of' the time-series is x_i until such time as we observe x_i+1.","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Sometimes it is useful to define x(t_-) = oslash forall t_- in mathcalT setminus mathcalT_x. Here, oslash is a placeholder element that simply means \"no value\".","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"info: Info\nNote that time is strictly increasing, and repeated times are not permitted. This conceptual choice is necessary to consider x to be a map from time to value as above. Without this restriction, there is an ambiguity whenever a time is repeated.","category":"page"},{"location":"concepts/#Functions-of-time-series","page":"Concepts","title":"Functions of time-series","text":"","category":"section"},{"location":"concepts/#General-case","page":"Concepts","title":"General case","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"We wish to define a general notion of a function f  mathcalTS times cdots times mathcalTS rightarrow mathcalTS. Let z = f(x y ldots), where x, y and z are all time-series.","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Firstly, we define an indicator-like function f_t(t ldots) in 01, which returns 1 iff we should emit a value at time t:","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"t_i = t in mathcalT  f_t(t x(t)  t leq t y(t)  t leq t ldots) = 1","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Colloquially, whenever f_t returns 1 we say that z ticks, i.e. emits a knot.","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Then, we require that each value z_i at time t_i can be written as the result of a function f:","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"z_i = f(t_i x(t)  t leq t_i y(t)  t leq t_i ldots)","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"info: Info\nLet us unpack this notation a bit:Knots of z are only allowed to depend on non-future values of x and y.\nz can tick whenever it likes, possibly dependent on values of x and y.\nThe knot emitted can be a function of time.The first of these is an important requirement, and TimeDag aims to enforce this structurally.","category":"page"},{"location":"concepts/#Parameters","page":"Concepts","title":"Parameters","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"In the above discussion, all arguments to f are time-series. Such functions could additionally have some other non-time-series constant parameters, which we will denote thetainTheta. Strictly mathematically, note that a \"constant\" can just be viewed as a time-series with a single observation at min mathcalT; so the above description is still fully general.","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"In practice (for efficient implementation) we will want function f  Theta times mathcalTS times cdots rightarrow mathcalTS. So, f(theta x y ldots) then has some constant parameter(s) theta.","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"We'll continue to drop the explicit theta dependence where it isn't interesting, to simplify notation.","category":"page"},{"location":"concepts/#Explicit-state","page":"Concepts","title":"Explicit state","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"It is useful to re-write the value computation by introducing the notion of a 'state' zeta_i:","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"beginaligned\nz_i zeta_i = f_v(t_i zeta_i-1 x(t_i) y(t_i) ldots)\nendaligned","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Each state zeta_i-1 needs to package as much information about the history of the inputs as necessary to compute each z_i (as well as the new state zeta_i).","category":"page"},{"location":"concepts/#Batching","page":"Concepts","title":"Batching","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Note that, even after the re-arrangement in Explicit state, f_t is still a bit awkward. One cannot directly implement it — otherwise one has to call f_t for every t in an infinite (or at least very large) set.","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"First, let us introduce the notion of slicing. Define an interval delta = t_1t_2) subset mathcalT.[3] Then, the slice of x over delta, which we'll write as x = xdelta, is a new time-series with support mathcalT_x = delta cap mathcalT_x.","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"[3]: One is free to choose the open/closed-ness of each bound, however the use of an closed-open interval helps in subsequent analysis.","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Let delta_i represent an ordered non-overlapping set of intervals, whose union covers all of mathcalT. We then write, analogous to the definition of f_v:","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"zdelta_i zeta_sup delta_i = f_b(delta_i zeta_sup delta_i-1 xdelta_i ydelta_i ldots)","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"This function outputs knots — time-value pairs — rather than just the values, and hence performs the roles of both f_t and f_v previously.","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"NB supdelta_i indicates the supremum of the interval delta_i, i.e. the upper bound. The state zeta is only subscripted by this upper bound; i.e. by a time, because it should not be path dependent. i.e. for a given time-series operation, we should always end up with the same state at a particular time, regardless of how many batches we have used to get there.","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"info: Info\nIt is useful to emphasise this distinction:f — a time-series operation. This is TimeDag.NodeOp.\nf_b — the implementation of f. This is TimeDag.run_node!.Helpfully, often f has simple semantics & behaviour that can be reasoned about. The implementation details can be ignored in this reasoning.","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"warning: Warning\nA little thought shows that f_b, and hence TimeDag.run_node!, can express illegal time-series operations that future-peek. Care must be taken when implementing this low-level interface!Where possible, when custom operations are required, use the higher-level abstractions referred to below.","category":"page"},{"location":"concepts/#Classes-of-function","page":"Concepts","title":"Classes of function","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"All time-series functions in TimeDag are of the form of f above. Here we identify a few categories of such functions which cover many of the cases of interest.","category":"page"},{"location":"concepts/#No-inputs","page":"Concepts","title":"No inputs","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"A function f  emptyset rightarrow mathcalTS can be considered a source. That is, it generates a time-series with no inputs.","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"In this case, if z = f(), then the implementation f_b technically reduces to zdelta = f_b(delta). In principle no state is required, since there is no external information to remember. However, in practice retaining the state term can be useful to increase implementation efficiency.","category":"page"},{"location":"concepts/#Single-input-(map-over-values)","page":"Concepts","title":"Single input (map over values)","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Consider an unary - function operating on a time-series; z = -x. This is a \"boring\" time-series operation, in that all times of z are identical to those of x. The values are determined by z_i = -x_i forall i.","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Some unary operators from Base, like Base.:-, have methods on TimeDag.Node defined within TimeDag.","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"More generally, wrap and wrapb let you create a time-series function from such an unary function. See Creating operations for more details.","category":"page"},{"location":"concepts/#Single-input-(lag)","page":"Concepts","title":"Single input (lag)","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"A lag is a slightly more complex unary function. Rather than explain it mathematically, a visualisation can help:","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"(Image: lag)","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Time is increasing to the right. Each grey arrow indicates that one value is used in computing another — in the case of lag, the value is simply used directly. Note how, for this function, we never introduce new timestamps — we simply 'lag' the previous value onto the next timestamp. ","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"A related concept is a time-lag, where each knot would be delayed by some fixed period of time partial t:","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"(Image: Time lag)","category":"page"},{"location":"concepts/#Single-input-(cumulative-sum)","page":"Concepts","title":"Single input (cumulative sum)","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Similarly to a simple function operation on values, a cumulative sum over time (Base.sum) ticks whenever the input ticks. However, this time each value is a function of all preceding knots:","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"(Image: sum)","category":"page"},{"location":"concepts/#Alignment","page":"Concepts","title":"Alignment","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"When considering a function of two or more time-series, a useful special-case is where the output ticks at some subset of the times that all the inputs tick. We consider alignment, which is a selection process with semantics similar (but not identical) to \"joins\" in database terminology.","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"We define three ways of performing alignment. For each one we document the TimeDag constant which should be used in function calls that accept an alignment, and give a graphical interpretation. Each diagram is shown for the case of two inputs; the docstrings describe the general case with more inputs.","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Functions in TimeDag that accept multiple nodes typically default to using UNION alignment.","category":"page"},{"location":"concepts/#Union","page":"Concepts","title":"Union","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Similar to an \"outer join\", with the key difference that we only emit knots once all inputs have started ticking.","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"UNION","category":"page"},{"location":"concepts/#TimeDag.UNION","page":"Concepts","title":"TimeDag.UNION","text":"UNION\n\nFor inputs (A, B, ...), tick whenever any input ticks so long as all inputs are active.\n\n\n\n\n\n","category":"constant"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"(Image: Union alignment)","category":"page"},{"location":"concepts/#Intersect","page":"Concepts","title":"Intersect","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Tick if and only if both inputs tick. This is identical to an \"inner join\".","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"INTERSECT","category":"page"},{"location":"concepts/#TimeDag.INTERSECT","page":"Concepts","title":"TimeDag.INTERSECT","text":"INTERSECT\n\nFor inputs (A, B, ...), tick whenever all inputs tick simultaneously.\n\n\n\n\n\n","category":"constant"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"(Image: Intersect alignment)","category":"page"},{"location":"concepts/#Left","page":"Concepts","title":"Left","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Similar to a \"left join\", with the key difference that we only emit knots once all inputs have started ticking.","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"LEFT","category":"page"},{"location":"concepts/#TimeDag.LEFT","page":"Concepts","title":"TimeDag.LEFT","text":"LEFT\n\nFor inputs (A, B, ...), tick whenever A ticks so long as all inputs are active.\n\n\n\n\n\n","category":"constant"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"(Image: Left alignment)","category":"page"},{"location":"concepts/#Initial-values","page":"Concepts","title":"Initial values","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"For the alignments above, it was noted that we have to wait for all inputs to start ticking before the output ticks.","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"It is possible to tell TimeDag that a given operation should consider its inputs to have some initial values. This behaves a little like a knot at the start of the evaluation window, however does not result in the creation of an output knot at that time. In the notation above, it is the definition of a value for x(t_-) which isn't oslash.","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Initial values are set seperately for each input. Most functions of two or more nodes will take an initial_values keyword argument to specify these.","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Some more implementation details on the lower-level functionality that controls this is provided in Alignment implementation.","category":"page"},{"location":"concepts/#Computational-graph","page":"Concepts","title":"Computational graph","text":"","category":"section"},{"location":"concepts/#Nodes","page":"Concepts","title":"Nodes","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"So far we have introduced the notion of time-series operations. By working purely with TimeDag.NodeOps, we build up an abstract representation of the computation we want to do. A TimeDag.Node contains zero or more input nodes, as well as a TimeDag.NodeOp defining how they should be combined.","category":"page"},{"location":"concepts/#Evaluation","page":"Concepts","title":"Evaluation","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"When we wish to evaluate a node over some interval delta, we first evaluate all input nodes over the same interval, recursively. Given all inputs, we can evaluate a particular node using f_b, as defined previously. The practicalities of this are discussed further in Advanced evaluation.","category":"page"},{"location":"concepts/#Subgraph-elimination","page":"Concepts","title":"Subgraph elimination","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"By using an Identity map we ensure that we never create duplicate nodes. This effectively eliminates the creation of common subgraphs, which means that when performing evaluation we never repeat work.","category":"page"},{"location":"reference/sources/#Sources","page":"Sources","title":"Sources","text":"","category":"section"},{"location":"reference/sources/","page":"Sources","title":"Sources","text":"The following functions construct nodes with no parents.","category":"page"},{"location":"reference/sources/","page":"Sources","title":"Sources","text":"block_node\nconstant\nempty_node\niterdates\npulse\ntea_file","category":"page"},{"location":"reference/sources/#TimeDag.block_node","page":"Sources","title":"TimeDag.block_node","text":"block_node(block::Block)\n\nConstruct a node whose values are read directly from the given block.\n\n\n\n\n\n","category":"function"},{"location":"reference/sources/#TimeDag.constant","page":"Sources","title":"TimeDag.constant","text":"constant(value) -> Node\n\nExplicitly wrap value into a TimeDag constant node, regardless of its type.\n\nIn many cases this isn't required, since many TimeDag functions which expect nodes will automatically wrap non-node arguments into a constant node.\n\nwarning: Warning\nIf value is already a node, this will wrap it up in an additional node. This is very likely not what you want to do.\n\n\n\n\n\n","category":"function"},{"location":"reference/sources/#TimeDag.empty_node","page":"Sources","title":"TimeDag.empty_node","text":"empty_node(T)\n\nConstruct a node with value type T which, if evaluated, will never tick.\n\n\n\n\n\n","category":"function"},{"location":"reference/sources/#TimeDag.iterdates","page":"Sources","title":"TimeDag.iterdates","text":"iterdates(time_of_day::Time=Time(0), tz::TimeZone=tz\"UTC\", occurrence=1)\n\nCreate a node which ticks exactly once a day at time_of_day in timezone tz.\n\nThis defaults to midnight in UTC. If tz is set otherwise, then each knot will appear at time_of_day in that timezone.\n\nNote that:     * All knot times in TimeDag are considered to be in UTC.     * It is possible to select a time_of_day that does not exist for every day. This will         lead to an exception being raised during evaluation.\n\nIn a given knot, each value will be of type DateTime, and equal the time of the knot.\n\n\n\n\n\n","category":"function"},{"location":"reference/sources/#TimeDag.pulse","page":"Sources","title":"TimeDag.pulse","text":"pulse(delta::TimePeriod[; epoch::DateTime])\n\nObtain a node which ticks every delta. Each value will equal the time of the knot.\n\nKnots will be placed such that the difference between its time and epoch will always be an integer multiple of delta. By default epoch is set to the Julia DateTime epoch, which is DateTime(0, 12, 31).\n\n\n\n\n\n","category":"function"},{"location":"reference/sources/#TimeDag.tea_file","page":"Sources","title":"TimeDag.tea_file","text":"tea_file(path::AbstractString, value_field_name)\n\nGet a node that will read data from the tea file at path.\n\nSuch a tea file must observe the following properties, which will be verified at runtime:\n\nHave a primary time field which is compatible with a Julia DateTime.\nHave exactly one column with name value_field_name.\nHave strictly increasing times.\n\nUpon node creation, the metadata section of the file will be parsed to infer the value type of the resulting node. However, the bulk of the data will only be read at evaluation time.\n\nSee also\n\nThe tea file spec\nTeaFiles.jl\n\n\n\n\n\n","category":"function"},{"location":"reference/online_windowed/#Online-and-windowed","page":"Online & windowed","title":"Online & windowed","text":"","category":"section"},{"location":"reference/online_windowed/#History","page":"Online & windowed","title":"History","text":"","category":"section"},{"location":"reference/online_windowed/","page":"Online & windowed","title":"Online & windowed","text":"history","category":"page"},{"location":"reference/online_windowed/#TimeDag.history","page":"Online & windowed","title":"TimeDag.history","text":"history(x::Node{T}, window::Int) -> Node{Vector{T}}\n\nCreate a node whose values represent the last window values seen in x.\n\nEach value will be vector of length window, and the result will only start ticking once window values have been seen. The vector value contains time-ordered observations, with the most recent observation last.\n\n\n\n\n\n","category":"function"},{"location":"reference/online_windowed/#Cumulative-and-rolling-statistics","page":"Online & windowed","title":"Cumulative & rolling statistics","text":"","category":"section"},{"location":"reference/online_windowed/","page":"Online & windowed","title":"Online & windowed","text":"Base.prod\nBase.sum\nStatistics.mean\nStatistics.var\nStatistics.std\nStatistics.cov\nStatistics.cor\nema","category":"page"},{"location":"reference/online_windowed/#Base.prod","page":"Online & windowed","title":"Base.prod","text":"prod(x::Node) -> Node\n\nCreate a node which ticks when x ticks, with values of the cumulative product of x.\n\n\n\n\n\nprod(x::Node, window::Int; emit_early::Bool=false) -> Node\nprod(x::Node, window::TimePeriod; emit_early::Bool=false) -> Node\n\nCreate a node of the rolling product of x over the last window knots, or time interval.\n\nIf emit_early is false, then the node returned will only start ticking once the window is full. Otherwise, it will tick immediately with a partially-filled window.\n\n\n\n\n\n","category":"function"},{"location":"reference/online_windowed/#Base.sum","page":"Online & windowed","title":"Base.sum","text":"sum(x::Node) -> Node\n\nCreate a node which ticks when x ticks, with values of the cumulative sum of x.\n\n\n\n\n\nsum(x::Node, window::Int; emit_early::Bool=false) -> Node\nsum(x::Node, window::TimePeriod; emit_early::Bool=false) -> Node\n\nCreate a node of the rolling sum of x over the last window knots, or time interval.\n\nIf emit_early is false, then the node returned will only start ticking once the window is full. Otherwise, it will tick immediately with a partially-filled window.\n\n\n\n\n\n","category":"function"},{"location":"reference/online_windowed/#Statistics.mean","page":"Online & windowed","title":"Statistics.mean","text":"mean(x::Node) -> Node\n\nCreate a node which ticks when x ticks, with values of the running mean of x.\n\n\n\n\n\nmean(x::Node, window::Int; emit_early::Bool=false) -> Node\nmean(x::Node, window::TimePeriod; emit_early::Bool=false) -> Node\n\nCreate a node of the rolling mean of x over the last window knots, or time interval.\n\nIf emit_early is false, then the node returned will only start ticking once the window is full. Otherwise, it will tick immediately with a partially-filled window.\n\n\n\n\n\n","category":"function"},{"location":"reference/online_windowed/#Statistics.var","page":"Online & windowed","title":"Statistics.var","text":"var(x::Node; corrected::Bool=true) -> Node\n\nCreate a node which ticks when x ticks, with values of the running variance of x.\n\nThis is equivalent to a sample variance over the n values of x observed at and before a given time. If corrected is true (the default), we normalise by n-1, otherwise we normalise by n.\n\n\n\n\n\nvar(x::Node, window::Int; emit_early::Bool=false, corrected::Bool=true) -> Node\nvar(x::Node, window::TimePeriod; emit_early::Bool=false, corrected::Bool=true) -> Node\n\nCreate a node of the rolling variance of x over the last window knots, or time interval.\n\nIf emit_early is false, then the node returned will only start ticking once the window is full. Otherwise, it will tick immediately with a partially-filled window.\n\nThis is equivalent to a sample variance over the n values of x (capped at window), observed at and before a given time. If corrected is true (the default), we normalise by n-1, otherwise we normalise by n.\n\n\n\n\n\n","category":"function"},{"location":"reference/online_windowed/#Statistics.std","page":"Online & windowed","title":"Statistics.std","text":"std(x::Node; corrected::Bool=true) -> Node\n\nCreate a node which ticks when x ticks, with values of the running standard deviation of x.\n\nThis is equivalent to sqrt(var(x; corrected)).\n\n\n\n\n\nstd(x::Node, window::Int; emit_early::Bool=false, corrected::Bool=true) -> Node\nstd(x::Node, window::TimePeriod; emit_early::Bool=false, corrected::Bool=true) -> Node\n\nCreate a node of the rolling standard deviation of x over the last window knots, or time interval.\n\nIf emit_early is false, then the node returned will only start ticking once the window is full. Otherwise, it will tick immediately with a partially-filled window.\n\nThis is equivalent to sqrt(var(x, window; emit_early, corrected)).\n\n\n\n\n\n","category":"function"},{"location":"reference/online_windowed/#Statistics.cov","page":"Online & windowed","title":"Statistics.cov","text":"cov(x, y[, alignment]; corrected::Bool=true) -> Node\n\nCreate a node which ticks with values of the running covariance of x and y.\n\nThe specified alignment controls the behaviour when x and y tick at different times, as per the documentation in Alignment. When not specified, it defaults to UNION.\n\nThis is equivalent to a sample covariance over the n values of (x, y) pairs observed at and before a given time. If corrected is true (the default), we normalise by n-1, otherwise we normalise by n.\n\n\n\n\n\ncov(x, y, window::Int[, alignment]; emit_early=false, corrected=true) -> Node\ncov(x, y, window::TimePeriod[, alignment]; emit_early=false, corrected=true) -> Node\n\nCreate a node of the rolling covariance of x and y over the last window knots, or time interval.\n\nThe specified alignment controls the behaviour when x and y tick at different times, as per the documentation in Alignment. When not specified, it defaults to UNION.\n\nIf emit_early is false, then the node returned will only start ticking once the window is full. Otherwise, it will tick immediately with a partially-filled window.\n\nThis is equivalent to a sample covariance over the n values of (x, y) pairs observed at and before a given time, with n capped at window. If corrected is true (the default), we normalise by n-1, otherwise we normalise by n.\n\n\n\n\n\ncov(x::Node{<:AbstractVector}; corrected::Bool=true) -> Node\n\nCreate a node which ticks with values of the running covariance of x.\n\nwarning: Warning\nIf the values of x change shape over time, this node will throw an exception during evaluation.\n\n\n\n\n\ncov(x::Node{<:AbstractVector}, window::Int; corrected::Bool=true) -> Node\n\nCreate a node of the rolling covariance of x over the last window knots.\n\nIf emit_early is false, then the node returned will only start ticking once the window is full. Otherwise, it will tick immediately with a partially-filled window.\n\nwarning: Warning\nIf the values of x change shape over time, this node will throw an exception during evaluation.\n\n\n\n\n\n","category":"function"},{"location":"reference/online_windowed/#Statistics.cor","page":"Online & windowed","title":"Statistics.cor","text":"cor(x, y[, alignment]; corrected::Bool=true) -> Node\n\nCreate a node which ticks with values of the running correlation of x and y.\n\nThe specified alignment controls the behaviour when x and y tick at different times, as per the documentation in Alignment. When not specified, it defaults to UNION.\n\nThis is equivalent to a sample correlation over the n values of (x, y) pairs observed at and before a given time.\n\n\n\n\n\ncor(x, y, window::Int[, alignment]; emit_early=false) -> Node\ncor(x, y, window::TimePeriod[, alignment]; emit_early=false) -> Node\n\nCreate a node of the rolling covariance of x and y over the last window knots, or time interval.\n\nThe specified alignment controls the behaviour when x and y tick at different times, as per the documentation in Alignment. When not specified, it defaults to UNION.\n\nIf emit_early is false, then the node returned will only start ticking once the window is full. Otherwise, it will tick immediately with a partially-filled window.\n\nThis is equivalent to a sample correlation over the n values of (x, y) pairs observed at and before a given time, with n capped at window.\n\n\n\n\n\n","category":"function"},{"location":"reference/online_windowed/#TimeDag.ema","page":"Online & windowed","title":"TimeDag.ema","text":"ema(x::Node, α::AbstractFloat) -> Node\nema(x::Node, w_eff::Integer) -> Node\n\nCreate a node which computes the exponential moving average of x.\n\nThe decay is specified either by α, which should satisfy 0 < α < 1, or by w_eff, which should be an integer greater than 1. If the latter is specified, then we compute α = 2 / (w_eff + 1).\n\nFor internal state s_t, with s_0 = 0, and resulting EMA series m_t, this has the form:\n\nbeginaligned\ns_t = s_t-1 + (1 - alpha) x_t \nm_t = fracalpha s_t1 - (1 - alpha)^t\nendaligned\n\nFor further information, see the notational conventions and discussion on Wikipedia. Note that this function implements the variant including the correction for the initial convergence problem.\n\n\n\n\n\n","category":"function"},{"location":"reference/misc_ops/#Miscellaneous","page":"Miscellaneous","title":"Miscellaneous","text":"","category":"section"},{"location":"reference/misc_ops/#Arrays-and-indexing","page":"Miscellaneous","title":"Arrays & indexing","text":"","category":"section"},{"location":"reference/misc_ops/","page":"Miscellaneous","title":"Miscellaneous","text":"Base.getindex\nBase.vec","category":"page"},{"location":"reference/misc_ops/#Base.getindex","page":"Miscellaneous","title":"Base.getindex","text":"getindex(x::Node, args...)\n\nA node whose values are generated by calling getindex(value, args...) on each value obtained from the node x.\n\n\n\n\n\n","category":"function"},{"location":"reference/misc_ops/#Base.vec","page":"Miscellaneous","title":"Base.vec","text":"vec(x::Node{<:AbstractArray}) -> Node{<:AbstractVector}\n\nReturn a vector whose values are those of x, but flattened into a single vector.\n\nIf x has values which are already an AbstractVector, this will be a no-op.\n\n\n\n\n\n","category":"function"},{"location":"reference/misc_ops/#Random","page":"Miscellaneous","title":"Random","text":"","category":"section"},{"location":"reference/misc_ops/","page":"Miscellaneous","title":"Miscellaneous","text":"Base.rand","category":"page"},{"location":"reference/misc_ops/#Base.rand","page":"Miscellaneous","title":"Base.rand","text":"rand([rng=MersenneTwister(),] alignment::Node[, S, dims...])\n\nGenerate random numbers aligned to alignment, with the given rng if provided.\n\nSemantics are otherwise very similar to the usual Base.rand:\n\nIf specified, S will be the element type, and will default to Float64 otherwise.\nIf specified, dims should be a tuple or vararg of integers representing the dimensions   of an array.\n\nNB The values of alignment will be ignored.\n\ntip: Tip\nIf provided, rng will be copied before it is used. This is to ensure reproducability when evaluating a node multiple times.\n\n\n\n\n\n","category":"function"},{"location":"reference/misc_ops/#Conditional","page":"Miscellaneous","title":"Conditional","text":"","category":"section"},{"location":"reference/misc_ops/","page":"Miscellaneous","title":"Miscellaneous","text":"Base.filter\nBase.skipmissing","category":"page"},{"location":"reference/misc_ops/#Base.filter","page":"Miscellaneous","title":"Base.filter","text":"filter(f::Function, x::Node) -> Node\n\nObtain a node that removes knots for which f(value) is false.\n\nThe value_type of the returned node is the same as that for the input x.\n\n\n\n\n\n","category":"function"},{"location":"reference/misc_ops/#Base.skipmissing","page":"Miscellaneous","title":"Base.skipmissing","text":"skipmissing(x::Node{T}) -> Node{nonmissingtype(T)}\n\nObtain a node which ticks with the values of x, so long as that value is not missing.\n\nThe value_type of the node that is returned will always be the nonmissingtype of the value_type of x.\n\nIn the case that x cannot tick with missing (based on its value_type), we just return x.\n\n\n\n\n\n","category":"function"},{"location":"reference/align/#Alignment-ops","page":"Alignment ops","title":"Alignment ops","text":"","category":"section"},{"location":"reference/align/","page":"Alignment ops","title":"Alignment ops","text":"left\nright\nalign\nalign_once\ncoalign\nfirst_knot\nactive_count\nprepend\nthrottle\nlag\nBase.diff\ncount_knots","category":"page"},{"location":"reference/align/#TimeDag.left","page":"Alignment ops","title":"TimeDag.left","text":"left(x, y[, alignment::Alignment; initial_values=nothing]) -> Node\n\nConstruct a node that ticks according to alignment with the latest value of x.\n\nIt is \"left\", in the sense of picking the left-hand of the two arguments x and y.\n\n\n\n\n\n","category":"function"},{"location":"reference/align/#TimeDag.right","page":"Alignment ops","title":"TimeDag.right","text":"right(x, y[, alignment::Alignment; initial_values=nothing]) -> Node\n\nConstruct a node that ticks according to alignment with the latest value of y.\n\nIt is \"right\", in the sense of picking the right-hand of the two arguments x and y.\n\n\n\n\n\n","category":"function"},{"location":"reference/align/#TimeDag.align","page":"Alignment ops","title":"TimeDag.align","text":"align(x, y) -> Node\n\nForm a node that ticks with the values of x whenever y ticks.\n\n\n\n\n\n","category":"function"},{"location":"reference/align/#TimeDag.align_once","page":"Alignment ops","title":"TimeDag.align_once","text":"align_once(x, y) -> Node\n\nSimilar to align(x, y), except knots from x will be emitted at most once.\n\nThis means that the resulting node will tick at a subset of the times that y ticks.\n\n\n\n\n\n","category":"function"},{"location":"reference/align/#TimeDag.coalign","page":"Alignment ops","title":"TimeDag.coalign","text":"coalign(node_1, [node_2...; alignment::Alignment]) -> Node...\n\nGiven at least one node(s) x, or values that are convertible to nodes, align all of them.\n\nWe guarantee that all nodes that are returned will have the same alignment. The values of each node will correspond to the values of the input nodes.\n\nThe choice of alignment is controlled by alignment, which defaults to UNION.\n\n\n\n\n\n","category":"function"},{"location":"reference/align/#TimeDag.first_knot","page":"Alignment ops","title":"TimeDag.first_knot","text":"first_knot(x::Node{T}) -> Node{T}\n\nGet a node which ticks with only the first knot of x, and then never ticks again.\n\n\n\n\n\n","category":"function"},{"location":"reference/align/#TimeDag.active_count","page":"Alignment ops","title":"TimeDag.active_count","text":"active_count(nodes...) -> Node{Int64}\n\nGet a node of the number of the given nodes (at least one) which are active.\n\n\n\n\n\n","category":"function"},{"location":"reference/align/#TimeDag.prepend","page":"Alignment ops","title":"TimeDag.prepend","text":"prepend(x, y) -> Node\n\nCreate a node that ticks with knots from x until y is active, and thereafter from y.\n\nNote that the value_type of the returned node will be that of the promoted value types of x and y.\n\n\n\n\n\n","category":"function"},{"location":"reference/align/#TimeDag.throttle","page":"Alignment ops","title":"TimeDag.throttle","text":"throttle(x::Node, n::Integer) -> Node\n\nReturn a node that only ticks every n knots.\n\nThe first knot encountered on the input will always be emitted.\n\ninfo: Info\nThe throttled node is stateful and depends on the starting point of the evaluation.\n\n\n\n\n\n","category":"function"},{"location":"reference/align/#TimeDag.lag","page":"Alignment ops","title":"TimeDag.lag","text":"lag(x::Node, n::Integer)\n\nConstruct a node which takes values from x, but lags them by n knots.\n\nThis means that we do not introduce any new timestamps that do not appear in x, however we will not emit knots for the first n values that appear when evaluating x.\n\n\n\n\n\nlag(x::Node, w::TimePeriod)\n\nConstruct a node which takes values from x, but lags them by period w.\n\n\n\n\n\n","category":"function"},{"location":"reference/align/#Base.diff","page":"Alignment ops","title":"Base.diff","text":"diff(x::Node[, n=1])\n\nCompute the n-knot difference of x, i.e. x - lag(x, n).\n\n\n\n\n\n","category":"function"},{"location":"reference/align/#TimeDag.count_knots","page":"Alignment ops","title":"TimeDag.count_knots","text":"count_knots(x) -> Node{Int64}\n\nReturn a node that ticks with the number of knots seen in x since evaluation began.\n\n\n\n\n\n","category":"function"},{"location":"reference/internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"reference/internals/","page":"Internals","title":"Internals","text":"This page documents internal, and less commonly-used API. Some of it will be useful for users for more advanced use-cases, like running graphs in production systems. Other parts shouldn't need to be regularly interacted with, but can be useful to know about.","category":"page"},{"location":"reference/internals/#Identity-map","page":"Internals","title":"Identity map","text":"","category":"section"},{"location":"reference/internals/","page":"Internals","title":"Internals","text":"One of the key features of TimeDag is avoiding duplicating work.","category":"page"},{"location":"reference/internals/","page":"Internals","title":"Internals","text":"This is primarily achieved by ensuring that we never construct the 'same' node twice. By 'same', here we mean two nodes that we can prove will always give the same output.","category":"page"},{"location":"reference/internals/","page":"Internals","title":"Internals","text":"One easy-to-handle case is that of a node that has identical parents & op to another. To avoid this, TimeDag maintains a global identity map, of type TimeDag.IdentityMap.","category":"page"},{"location":"reference/internals/","page":"Internals","title":"Internals","text":"Currently the only implementation of the identity map is TimeDag.WeakIdentityMap. This contains weak references to nodes, to ensure that we know about all nodes that currently exist, but don't unnecessarily prevent nodes from being garbage collected when we no longer want them.","category":"page"},{"location":"reference/internals/","page":"Internals","title":"Internals","text":"In practice, all nodes should be constructed indirectly using TimeDag.obtain_node.  This will query the global_identity_map(), and only construct a new node if an equivalent one does not already exist.","category":"page"},{"location":"reference/internals/","page":"Internals","title":"Internals","text":"TimeDag.IdentityMap\nTimeDag.obtain_node!\nTimeDag.global_identity_map\nTimeDag.WeakNode\nTimeDag.WeakIdentityMap","category":"page"},{"location":"reference/internals/#TimeDag.IdentityMap","page":"Internals","title":"TimeDag.IdentityMap","text":"IdentityMap\n\nAn abstract identity map.\n\nAny implementation of this type needs to implement obtain_node!.\n\n\n\n\n\n","category":"type"},{"location":"reference/internals/#TimeDag.obtain_node!","page":"Internals","title":"TimeDag.obtain_node!","text":"obtain_node!(id_map::IdentityMap, parents::NTuple{N,Node}, op::NodeOp) -> Node\n\nIf a node with parents and op doesn't exist inside id_map, create and insert it.\n\nReturn either the new or existing node.\n\n\n\n\n\n","category":"function"},{"location":"reference/internals/#TimeDag.global_identity_map","page":"Internals","title":"TimeDag.global_identity_map","text":"global_identity_map() -> IdentityMap\n\nGet the global IdentityMap instance used in TimeDag.\n\n\n\n\n\n","category":"function"},{"location":"reference/internals/#TimeDag.WeakNode","page":"Internals","title":"TimeDag.WeakNode","text":"WeakNode(parents, op)\n\nRepresent a node-like object that doesn't hold strong references to its parents.\n\nThis exists purely such that hash and == do allow multiple instances of WeakNode to compare equal if they have the same parents and op.\n\n\n\n\n\n","category":"type"},{"location":"reference/internals/#TimeDag.WeakIdentityMap","page":"Internals","title":"TimeDag.WeakIdentityMap","text":"WeakIdentityMap\n\nRepresent a collection of nodes which doesn't hold strong references to any nodes.\n\nThis is useful, as it allows the existence of this cache to be somewhat transparent to the user, and they only have to care about holding on to references for nodes that they care about.\n\nThis structure contains nodes, but also node weak nodes – these allow us to determine whether we ought to create a given node.\n\n\n\n\n\n","category":"type"},{"location":"reference/internals/#Advanced-evaluation","page":"Internals","title":"Advanced evaluation","text":"","category":"section"},{"location":"reference/internals/","page":"Internals","title":"Internals","text":"This section goes into more detail about how evaluation works.  We explain evaluation state, and discuss how to use the API in a Live system.","category":"page"},{"location":"reference/internals/#Evaluation-state","page":"Internals","title":"Evaluation state","text":"","category":"section"},{"location":"reference/internals/","page":"Internals","title":"Internals","text":"Recall from the discussion in Concepts that we have the concept of Explicit state. For a particular node, this state will be a subtype of TimeDag.NodeEvaluationState. For consistency, all nodes have an evaluation state — for nodes that are fundamentally stateless, we use TimeDag.EMPTY_NODE_STATE.","category":"page"},{"location":"reference/internals/","page":"Internals","title":"Internals","text":"A fresh evaluation state is created by a call to TimeDag.create_evaluation_state. When creating a new TimeDag.NodeOp, a new method of this function should be defined to return the appropriate state. The state is subsequently mutated in calls TimeDag.run_node!, to reflect any changes induced over the time interval.","category":"page"},{"location":"reference/internals/","page":"Internals","title":"Internals","text":"TimeDag.NodeEvaluationState\nTimeDag.EmptyNodeEvaluationState\nTimeDag.EMPTY_NODE_STATE\nTimeDag.create_evaluation_state\nTimeDag.run_node!","category":"page"},{"location":"reference/internals/#TimeDag.NodeEvaluationState","page":"Internals","title":"TimeDag.NodeEvaluationState","text":"abstract type NodeEvaluationState end\n\nRepresents any and all state that a node must retain between evaluating batches.\n\nInstances of subtypes of NodeEvaluationState are given to run_node!.\n\n\n\n\n\n","category":"type"},{"location":"reference/internals/#TimeDag.EmptyNodeEvaluationState","page":"Internals","title":"TimeDag.EmptyNodeEvaluationState","text":"EmptyNodeEvaluationState()\n\nA NodeEvaluationState which has no content, to be used by non-stateful nodes.\n\nIn practice, the common instance TimeDag.EMPTY_NODE_STATE can be used.\n\n\n\n\n\n","category":"type"},{"location":"reference/internals/#TimeDag.EMPTY_NODE_STATE","page":"Internals","title":"TimeDag.EMPTY_NODE_STATE","text":"const EMPTY_NODE_STATE\n\nA singleton instance of TimeDag.EmptyNodeEvaluationState.\n\n\n\n\n\n","category":"constant"},{"location":"reference/internals/#TimeDag.create_evaluation_state","page":"Internals","title":"TimeDag.create_evaluation_state","text":"create_evaluation_state(node::Node) -> NodeEvaluationState\ncreate_evaluation_state(parents, node::NodeOp) -> NodeEvaluationState\n\nCreate an empty evaluation state for the given node, when starting evaluation at the specified time.\n\n\n\n\n\n","category":"function"},{"location":"reference/internals/#TimeDag.run_node!","page":"Internals","title":"TimeDag.run_node!","text":"run_node!(\n    op::NodeOp{T},\n    state::NodeEvaluationState,\n    time_start::DateTime,\n    time_end::DateTime,\n    input_blocks::Block...\n) -> Block{T}\n\nEvaluate the given node from time_start until time_end, with the initial state. Zero or more blocks will be passed as an input; these correspond to the parents of a node, and are passed in the same order as that returned by parents(node).\n\nWe return a new Block of output knots from this node.\n\nwarning: Warning\nThe implementer of run_node! must ensure:No future peeking occurs: i.e. that no output knot is dependent on input knots   that occur subsequently.\nCorrect time range: all output timestamps must be in the interval   [time_start, time_end).\nConsistency: Calling run_node! over a single interval should give the same   result as calling it multiple times over a decomposition of that same interval.\nDeterminism: run_node! should always be fully deterministic. If a   pseudo-random number generator is required, it should be held on the evaluation   state.\n\n\n\n\n\n","category":"function"},{"location":"reference/internals/","page":"Internals","title":"Internals","text":"When an evaluation is performed, we need to save the state of all the nodes in the graph. We package this into an TimeDag.EvaluationState instance. This object also retains the blocks from the nodes in whose output we're interested.","category":"page"},{"location":"reference/internals/","page":"Internals","title":"Internals","text":"TimeDag.EvaluationState","category":"page"},{"location":"reference/internals/#TimeDag.EvaluationState","page":"Internals","title":"TimeDag.EvaluationState","text":"EvaluationState\n\nAll state necessary for the evaluation of some nodes.\n\nThis should be created with start_at.\n\nFields\n\nordered_node_to_children::OrderedDict{Node,Set{Node}}: a map from every node which we   need to run, to its children. The ordering of the elements is such that, if evaluated in   this order, all dependencies will be evaluated before they are required.\nnode_to_state::IdDict{Node,NodeEvaluationState}: maintain the state for every node   being evaluated.\ncurrent_time::DateTime: the time to which this state corresponds.\nevaluated_node_to_blocks::IdDict{Node,Vector{Block}}: the output blocks that we care   about.\n\n\n\n\n\n","category":"type"},{"location":"reference/internals/#Deconstructing-evaluation","page":"Internals","title":"Deconstructing evaluation","text":"","category":"section"},{"location":"reference/internals/","page":"Internals","title":"Internals","text":"Whilst evaluate is the primary API for TimeDag, it is in fact a thin wrapper around a lower level API. Roughly, the steps involved are:","category":"page"},{"location":"reference/internals/","page":"Internals","title":"Internals","text":"Call TimeDag.start_at to create a new TimeDag.EvaluationState for a collection of nodes.  This will work out all the ancestors of the given nodes that also need to be evaluated.\nPerform one or more calls to TimeDag.evaluate_until!, depending on the batch interval.  Each call will update the evaluation state.  Interenally, this calls TimeDag.run_node! for every ancestor node.\nOnce the end of the evaluation interval has been reached, we extract the blocks for the nodes of interest from the evaluation state.  These are concatenated and returned to the user.","category":"page"},{"location":"reference/internals/","page":"Internals","title":"Internals","text":"TimeDag.start_at\nTimeDag.evaluate_until!","category":"page"},{"location":"reference/internals/#TimeDag.start_at","page":"Internals","title":"TimeDag.start_at","text":"start_at(nodes, time_start::DateTime) -> EvaluationState\n\nCreate a sufficient EvaluationState for the evaluation of nodes.\n\nInternally, this will determine the subgraph that needs evaluating, i.e. all the ancestors of nodes, and create a NodeEvaluationState for each of these.\n\n\n\n\n\n","category":"function"},{"location":"reference/internals/#TimeDag.evaluate_until!","page":"Internals","title":"TimeDag.evaluate_until!","text":"evaluate_until!(state::EvaluationState, time_end::DateTime)\n\nUpdate the evaluation state by performing the evalution for each node.\n\n\n\n\n\n","category":"function"},{"location":"reference/internals/#Live-system","page":"Internals","title":"Live system","text":"","category":"section"},{"location":"reference/internals/","page":"Internals","title":"Internals","text":"Consider the case where some history of data is available, say in a database, and new data is added continually, e.g. as it is recorded from a sensor. Suppose we have built a TimeDag graph representing the computation we wish to perform on this data. We can perform the following steps:","category":"page"},{"location":"reference/internals/","page":"Internals","title":"Internals","text":"Initialise the state with TimeDag.start_at.\nInitialise the model with one (or more) calls to TimeDag.evaluate_until!.  This is used to pull through historical data, e.g. to initialise stateful nodes like moving averages.\nIn real time, poll for new data with repeated calls to TimeDag.evaluate_until!","category":"page"},{"location":"reference/internals/","page":"Internals","title":"Internals","text":"The performance of this setup is naturally dependent upon the complexity of the model being evaluated. However, if models are appropriately designed to have efficient online updates, then the underlying overhead of TimeDag is sufficiently small for this to be usable with latencies of down to O(milliseconds).","category":"page"},{"location":"reference/internals/","page":"Internals","title":"Internals","text":"using Dates  # hide\nusing Statistics  # hide\nusing TimeDag  # hide\n# Some arbitrary data source - here just use random numbers.\nx = rand(pulse(Second(1)))\n\n# Compute a rolling mean and standard deviation.\n# Corresponds to 24-hour rolling windows, given one data point per second.\nn1, n2 = mean(x, 86400), std(x, 86400)\n\n# Initialise state over a long history.\nstate = TimeDag.start_at([n1, n2], DateTime(2019))\nstate = TimeDag.evaluate_until!(state, DateTime(2020))\n\n# Simulate an incremental update over a few hours.\n@time state = TimeDag.evaluate_until!(state, DateTime(2020, 1, 1, 3))\nnothing  # hide","category":"page"},{"location":"reference/internals/","page":"Internals","title":"Internals","text":"Note that this approach is unlikely to be suitable for lower latency applications (e.g. microseconds). For that case, one may benefit from a \"push mode\" evaluation, where new data are pushed onto the graph, and only affected nodes are re-evaluated. Such a feature isn't currently planned.","category":"page"},{"location":"reference/internals/#Scheduling","page":"Internals","title":"Scheduling","text":"","category":"section"},{"location":"reference/internals/","page":"Internals","title":"Internals","text":"TimeDag currently runs all nodes in a single thread, however this is subject to change in the future.","category":"page"},{"location":"reference/internals/#Alignment-implementation","page":"Internals","title":"Alignment implementation","text":"","category":"section"},{"location":"reference/internals/","page":"Internals","title":"Internals","text":"If we want to define a new op that follows alignment semantics, it should derive from one of the following types.","category":"page"},{"location":"reference/internals/","page":"Internals","title":"Internals","text":"TimeDag.UnaryNodeOp\nTimeDag.BinaryNodeOp\nTimeDag.NaryNodeOp","category":"page"},{"location":"reference/internals/#TimeDag.UnaryNodeOp","page":"Internals","title":"TimeDag.UnaryNodeOp","text":"UnaryNodeOp{T} <: NodeOp{T}\n\nAn abstract type representing a node op with a single parent.\n\n\n\n\n\n","category":"type"},{"location":"reference/internals/#TimeDag.BinaryNodeOp","page":"Internals","title":"TimeDag.BinaryNodeOp","text":"BinaryNodeOp{T,A<:Alignment} <: NodeOp{T}\n\nAn abstract type representing a node op with two parents, and using alignment A.\n\n\n\n\n\n","category":"type"},{"location":"reference/internals/#TimeDag.NaryNodeOp","page":"Internals","title":"TimeDag.NaryNodeOp","text":"NaryNodeOp{N,T,A<:Alignment} <: NodeOp{T}\n\nAn abstract type representing a node op with N parents, and using alignment A.\n\nThis type should be avoided for N < 3, since in these cases it would be more appropriate to use either TimeDag.UnaryNodeOp or TimeDag.BinaryNodeOp.\n\n\n\n\n\n","category":"type"},{"location":"reference/internals/","page":"Internals","title":"Internals","text":"Instead of implementing TimeDag.run_node! directly, one instead implements some of the following functions. The exact alignment logic is then encapsulated, and doesn't need to be dealt with directly.","category":"page"},{"location":"reference/internals/","page":"Internals","title":"Internals","text":"TimeDag.operator!\nTimeDag.always_ticks\nTimeDag.stateless_operator\nTimeDag.time_agnostic\nTimeDag.value_agnostic\nTimeDag.has_initial_values\nTimeDag.initial_left\nTimeDag.initial_right\nTimeDag.initial_values\nTimeDag.create_operator_evaluation_state","category":"page"},{"location":"reference/internals/#TimeDag.operator!","page":"Internals","title":"TimeDag.operator!","text":"operator!(op::UnaryNodeOp{T}, (state,), (time,) x) -> T / Maybe{T}\noperator!(op::BinaryNodeOp{T}, (state,), (time,) x, y) -> T / Maybe{T}\noperator!(op::NaryNodeOp{N,T}, (state,), (time,) x, y, z...) -> T / Maybe{T}\n\nPerform the operation for this node.\n\nWhen defining a method of this for a new op, follow these rules:\n\nstate should be omitted iff TimeDag.stateless_operator.\ntime should be omitted iff TimeDag.time_agnostic.\nAll values x, y, z... should be omittted iff TimeDag.value_agnostic.\n\nFor stateful operations, this operator should mutate state as required.\n\nThe return value out should be of type T iff TimeDag.always_ticks is true, otherwise it should be of type TimeDag.Maybe{T}.\n\nIf out <: Maybe{T}, and has !valid(out), this indicates that we do not wish to emit a knot at this time, and it will be skipped. Otherwise, value(out) will be used as the output value.\n\n\n\n\n\n","category":"function"},{"location":"reference/internals/#TimeDag.always_ticks","page":"Internals","title":"TimeDag.always_ticks","text":"always_ticks(node) -> Bool\nalways_ticks(op) -> Bool\n\nReturns true iff the return value from operator! can be assumed to always be valid.\n\nIf true, operator!(::Node{T}, ...) should return a T. If false, operator!(::Node{T}, ...) should return a Maybe{T}.\n\nNote, that for sensible performance characteristics, this should be knowable from typeof(op)\n\n\n\n\n\n","category":"function"},{"location":"reference/internals/#TimeDag.stateless_operator","page":"Internals","title":"TimeDag.stateless_operator","text":"stateless_operator(node) -> Bool\nstateless_operator(op) -> Bool\n\nReturns true iff operator(op, ...) would never look at or modify the evaluation state.\n\nIf this returns true, create_operator_evaluation_state will not be used.\n\nNote that if an op has stateless(op) returning true, then it necessarily should also return true here. The default implementation is to return stateless(op), meaning that if one is creating a node that is fully stateless, one need only define stateless.\n\nFor optimal performance, this should be knowable from the type of op alone.\n\n\n\n\n\n","category":"function"},{"location":"reference/internals/#TimeDag.time_agnostic","page":"Internals","title":"TimeDag.time_agnostic","text":"time_agnostic(node) -> Bool\ntime_agnostic(op) -> Bool\n\nReturns true iff op does not care about the time of the input knot(s).\n\nFor optimal performance, this should be knowable from the type of op alone.\n\n\n\n\n\n","category":"function"},{"location":"reference/internals/#TimeDag.value_agnostic","page":"Internals","title":"TimeDag.value_agnostic","text":"value_agnostic(node) -> Bool\nvalue_agnostic(op) -> Bool\n\nReturns true iff op does not care about the value(s) of the input knot(s).\n\nFor optimal performance, this should be knowable from the type of op alone.\n\n\n\n\n\n","category":"function"},{"location":"reference/internals/#TimeDag.has_initial_values","page":"Internals","title":"TimeDag.has_initial_values","text":"has_initial_values(op) -> Bool\n\nIf this returns true, it indicates that initial values for the op's parents are specified.\n\nSee the documentation on Initial values for further information.\n\n\n\n\n\n","category":"function"},{"location":"reference/internals/#TimeDag.initial_left","page":"Internals","title":"TimeDag.initial_left","text":"initial_left(op::BinaryNodeOp) -> L\n\nSpecify the initial value to use for the first parent of the given op.\n\nNeeds to be defined if has_initial_values returns true, and alignment is UNION. For other alignments it is not required.\n\n\n\n\n\n","category":"function"},{"location":"reference/internals/#TimeDag.initial_right","page":"Internals","title":"TimeDag.initial_right","text":"initial_right(op::BinaryNodeOp) -> R\n\nSpecify the initial value to use for the second parent of the given op.\n\nNeeds to be defined if has_initial_values(op) returns true, and alignment is UNION or LEFT. For INTERSECT alignment it is not required.\n\n\n\n\n\n","category":"function"},{"location":"reference/internals/#TimeDag.initial_values","page":"Internals","title":"TimeDag.initial_values","text":"initial_values(op::NaryNodeOp) -> Tuple\n\nSpecify the initial values to use for all parents of the given op.\n\nNeeds to be defined for nary ops for which has_initial_values returns true.\n\n\n\n\n\n","category":"function"},{"location":"reference/internals/#TimeDag.create_operator_evaluation_state","page":"Internals","title":"TimeDag.create_operator_evaluation_state","text":"create_operator_evaluation_state(parents, op::NodeOp) -> NodeEvaluationState\n\nCreate an empty evaluation state for the given node, when starting evaluation at the specified time.\n\nNote that this is state that will be passed to operator. The overall node may additionally wrap this state with further state, if this is necessary for e.g. alignment.\n\n\n\n\n\n","category":"function"},{"location":"reference/internals/","page":"Internals","title":"Internals","text":"For simple cases, the following node ops can be useful.","category":"page"},{"location":"reference/internals/","page":"Internals","title":"Internals","text":"tip: Tip\nRather than using the structures below directly, you probably want to use TimeDag.apply, wrap, or wrapb.","category":"page"},{"location":"reference/internals/","page":"Internals","title":"Internals","text":"TimeDag.SimpleUnary\nTimeDag.SimpleBinary\nTimeDag.SimpleBinaryUnionInitial\nTimeDag.SimpleBinaryLeftInitial\nTimeDag.SimpleNary\nTimeDag.SimpleNaryInitial","category":"page"},{"location":"reference/internals/#TimeDag.SimpleUnary","page":"Internals","title":"TimeDag.SimpleUnary","text":"SimpleUnary{f,TimeAgnostic,T}\n\nRepresents a stateless unary operator that will always emit a value.\n\nThe value of the TimeAgnostic type parmater is coupled to time_agnostic.\n\n\n\n\n\n","category":"type"},{"location":"reference/internals/#TimeDag.SimpleBinary","page":"Internals","title":"TimeDag.SimpleBinary","text":"SimpleBinary{f,TimeAgnostic,T,A}\n\nRepresents a stateless binary operator that will always emit a value.\n\nThe value of the TimeAgnostic type parmater is coupled to time_agnostic.\n\n\n\n\n\n","category":"type"},{"location":"reference/internals/#TimeDag.SimpleBinaryUnionInitial","page":"Internals","title":"TimeDag.SimpleBinaryUnionInitial","text":"SimpleBinaryUnionInitial{f,TimeAgnostic,T,L,R}\n\nRepresents a stateless binary operator that will always emit a value.\n\nThe value of the TimeAgnostic type parmater is coupled to time_agnostic.\n\nUnlike SimpleBinary, this also contains initial values for its parent nodes. See Initial values for more details.\n\n\n\n\n\n","category":"type"},{"location":"reference/internals/#TimeDag.SimpleBinaryLeftInitial","page":"Internals","title":"TimeDag.SimpleBinaryLeftInitial","text":"SimpleBinaryLeftInitial{f,T,R}\n\nRepresents a stateless binary operator that will always emit a value.\n\nThe value of the TimeAgnostic type parmater is coupled to time_agnostic.\n\nUnlike SimpleBinary, this also contains initial values for its right parent. See Initial values for more details.\n\n\n\n\n\n","category":"type"},{"location":"reference/internals/#TimeDag.SimpleNary","page":"Internals","title":"TimeDag.SimpleNary","text":"SimpleNary{f,TimeAgnostic,N,T,A}\n\nRepresents a stateless Nary operator that will always emit a value.\n\nThe value of the TimeAgnostic type parmater is coupled to time_agnostic.\n\n\n\n\n\n","category":"type"},{"location":"reference/internals/#TimeDag.SimpleNaryInitial","page":"Internals","title":"TimeDag.SimpleNaryInitial","text":"SimpleNaryInitial{f,TimeAgnostic,N,T,A,Types}\n\nRepresents a stateless binary operator that will always emit a value.\n\nThe value of the TimeAgnostic type parmater is coupled to time_agnostic.\n\nUnlike SimpleNary, this also contains initial values. See Initial values for more details.\n\n\n\n\n\n","category":"type"},{"location":"reference/internals/#Maybe","page":"Internals","title":"Maybe","text":"","category":"section"},{"location":"reference/internals/","page":"Internals","title":"Internals","text":"TimeDag.Maybe\nTimeDag.valid\nTimeDag.value\nTimeDag.unsafe_value","category":"page"},{"location":"reference/internals/#TimeDag.Maybe","page":"Internals","title":"TimeDag.Maybe","text":"Maybe{T}()\nMaybe(value::T)\n\nA structure which can hold a value of type T, or represent the absence of a value.\n\nThe API is optimised for speed over memory usage, by allowing a function that may otherwise return Union{T, Nothing} to instead always return Maybe{T}, and hence be type-stable.\n\n\n\n\n\n","category":"type"},{"location":"reference/internals/#TimeDag.valid","page":"Internals","title":"TimeDag.valid","text":"valid(x::Maybe) -> Bool\n\nReturn true iff x holds a value.\n\n\n\n\n\n","category":"function"},{"location":"reference/internals/#TimeDag.value","page":"Internals","title":"TimeDag.value","text":"value(x::Maybe{T}) -> T\n\nReturns the value stored in x, or throws an ArgumentError if !valid(x).\n\nNote that, in a tight loop, it is preferable to use a combination of calls to valid and unsafe_value, as it will generate more optimal code.\n\n\n\n\n\n","category":"function"},{"location":"reference/internals/#TimeDag.unsafe_value","page":"Internals","title":"TimeDag.unsafe_value","text":"unsafe_value(x::Maybe{T}) -> T\n\nReturns the value stored in x.\n\nIt is \"unsafe\" when !valid(x), in that the return value of this function is undefined. If T is a reference type, calling this function will result in an UndefRefError being thrown.\n\n\n\n\n\n","category":"function"},{"location":"reference/internals/#Other","page":"Internals","title":"Other","text":"","category":"section"},{"location":"reference/internals/","page":"Internals","title":"Internals","text":"TimeDag.output_type\nTimeDag.duplicate","category":"page"},{"location":"reference/internals/#TimeDag.output_type","page":"Internals","title":"TimeDag.output_type","text":"output_type(f, arg_types...)\n\nReturn the output type of the specified function. Tries to be fast where possible.\n\nwarning: Warning\nThis uses Base.promote_op, which is noted to be fragile. The problem is that whilst one might hope that typeof(f(map(oneunit, arg_types)...)) could be used, in practice there are a lot of types which do not define oneunit.Ultimately this represents a tension between the desire of TimeDag to know the type of the output of a node without yet knowing the concrete values of the input type.\n\n\n\n\n\n","category":"function"},{"location":"reference/internals/#TimeDag.duplicate","page":"Internals","title":"TimeDag.duplicate","text":"duplicate(x)\n\nReturn an object that is equal to x, but fully independent of it.\n\nNote that for any parts of x that TimeDag considers to be immutable (e.g. Blocks), this can return the identical object.\n\nConceptually this is otherwise very similar to deepcopy(x).\n\n\n\n\n\n","category":"function"},{"location":"reference/fundamentals/#Fundamentals","page":"Fundamentals","title":"Fundamentals","text":"","category":"section"},{"location":"reference/fundamentals/#Data","page":"Fundamentals","title":"Data","text":"","category":"section"},{"location":"reference/fundamentals/","page":"Fundamentals","title":"Fundamentals","text":"Time-series data is stored internally in a Block. More information on what we mean by a time-series is explained in Time-series.","category":"page"},{"location":"reference/fundamentals/","page":"Fundamentals","title":"Fundamentals","text":"Block","category":"page"},{"location":"reference/fundamentals/#TimeDag.Block","page":"Fundamentals","title":"TimeDag.Block","text":"Block{T}()\nBlock(times::AbstractVector{DateTime}, values::AbstractVector{T})\nBlock(unchecked, times, values)\n\nRepresent some data in timeseries.\n\nConceptually this is a list of (time, value) pairs, or \"knots\". Times must be strictly increasing — i.e. no repeated timestamps are allowed.\n\nThe constructor Block(times, values) will verify that the input data satisfies this constraint, however Block(unchecked, times, values) will skip the checks. This is primarily intended for internal use, where the caller assumes responsibility for the validity of times & values.\n\ndanger: Danger\nTimeDag considers instances of Block to be completely immutable. Thus, when working with functions that accept blocks (e.g. TimeDag.run_node!), you must not modify times or values members.\n\n\n\n\n\n","category":"type"},{"location":"reference/fundamentals/#Computational-graph","page":"Fundamentals","title":"Computational graph","text":"","category":"section"},{"location":"reference/fundamentals/","page":"Fundamentals","title":"Fundamentals","text":"The computational graph is formed of TimeDag.Node objects. A node is an abstract representation of a time-series, i.e. a sequence of (time, value) pairs. A node knows the type of its values, which can be queries with TimeDag.value_type.","category":"page"},{"location":"reference/fundamentals/","page":"Fundamentals","title":"Fundamentals","text":"Note that nodes should never be constructed directly by the user. Typically one will call a function like block_node or lag, which will construct a node.","category":"page"},{"location":"reference/fundamentals/","page":"Fundamentals","title":"Fundamentals","text":"TimeDag includes functions to construct many useful nodes, but often you will need to create a custom node. See Creating nodes for instructions on how to do this.","category":"page"},{"location":"reference/fundamentals/","page":"Fundamentals","title":"Fundamentals","text":"info: Info\nAll nodes should eventually be constructed with TimeDag.obtain_node. This uses the global Identity map to ensure that we do not duplicate nodes.","category":"page"},{"location":"reference/fundamentals/","page":"Fundamentals","title":"Fundamentals","text":"TimeDag.Node\nTimeDag.value_type","category":"page"},{"location":"reference/fundamentals/#TimeDag.Node","page":"Fundamentals","title":"TimeDag.Node","text":"Node(parents, op)\n\nA node in the computational graph that combines zero or more parents with op to produce a timeseries.\n\nwarning: Warning\nNote that a Node is only declared mutable so that we can attach finalizers to instances. This is required for the WeakIdentityMap to work. Nodes should NEVER actually be mutated!\n\nDue to subgraph elimination, nodes that are equivalent should always be identical objects. We therefore leave hash & == defined in terms of the objectid.\n\n\n\n\n\n","category":"type"},{"location":"reference/fundamentals/#TimeDag.value_type","page":"Fundamentals","title":"TimeDag.value_type","text":"value_type(node::Node{T}) -> T\n\nThe type of each value emitted for this node.\n\n\n\n\n\n","category":"function"},{"location":"reference/fundamentals/","page":"Fundamentals","title":"Fundamentals","text":"Every node contains parents, and a TimeDag.NodeOp.","category":"page"},{"location":"reference/fundamentals/","page":"Fundamentals","title":"Fundamentals","text":"TimeDag.NodeOp\nTimeDag.obtain_node","category":"page"},{"location":"reference/fundamentals/#TimeDag.NodeOp","page":"Fundamentals","title":"TimeDag.NodeOp","text":"abstract type NodeOp{T} end\n\nRepresent a time-series operation whose output will be a time-series with value type T.\n\n\n\n\n\n","category":"type"},{"location":"reference/fundamentals/#TimeDag.obtain_node","page":"Fundamentals","title":"TimeDag.obtain_node","text":"obtain_node(parents::NTuple{N,Node}, op::NodeOp) -> Node\n\nGet a node for the given op and parents. If an equivalent node already exists in the global identity map, use that one, otherwise create a new node, add to the identity map, and return it.\n\nConstant propagation\n\nIf all parents are constant nodes, and op has a well-defined operation on constant inputs, we will immediately perform the computation and return a constant node wrapping the computed value.\n\n\n\n\n\n","category":"function"},{"location":"reference/fundamentals/","page":"Fundamentals","title":"Fundamentals","text":"Given a node, a rough-and-ready way to visualise the graph on the command line is with AbstractTrees.print_tree. This will not directly indicated repeated nodes, but for small graphs the output can be useful.","category":"page"},{"location":"reference/fundamentals/#Evaluation","page":"Fundamentals","title":"Evaluation","text":"","category":"section"},{"location":"reference/fundamentals/","page":"Fundamentals","title":"Fundamentals","text":"In order to get a concrete time-series (as a Block) for a node, it must be evaluated with evaluate. Evaluation additionally requires a time range, and involves pulling data corresponding to this interval through the graph of ancestors of the given node(s).","category":"page"},{"location":"reference/fundamentals/","page":"Fundamentals","title":"Fundamentals","text":"tip: Tip\nWhen evaluating a graph in a production system, it may be desirable to have more control over evaluation. If this sounds like you, please read the Advanced evaluation section!","category":"page"},{"location":"reference/fundamentals/","page":"Fundamentals","title":"Fundamentals","text":"evaluate","category":"page"},{"location":"reference/fundamentals/#TimeDag.evaluate","page":"Fundamentals","title":"TimeDag.evaluate","text":"evaluate(nodes::AbstractVector{Node}, t0, t1[; batch_interval]) -> Vector{Block}\nevaluate(node::Node, t0, t1[; batch_interval]) -> Block\n\nEvaluate the specified node(s) over the specified time range [t0, t1), and return the corresponding Block(s).\n\nIf nodes have common dependencies, work will not be repeated when performing this evaluation.\n\n\n\n\n\n","category":"function"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The following examples demonstrate some of the basic functionality in TimeDag.","category":"page"},{"location":"examples/#Concrete-data","page":"Examples","title":"Concrete data","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"We represent concrete time-series data with instances of Block. Let's create one now, using daily price data for crude oil from MarketData.jl.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Dates\nusing MarketData: cl, timestamp, values\nusing Plots\nusing TimeDag\nblock = Block(DateTime.(timestamp(cl)), values(cl))","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Above it is represented in a raw table-like form.[1]  We can see that this block has values of type Float64. For Blocks with numeric value types, we can use the included plot recipe to visualise them:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"[1]: A Block is compatible with Tables.jl, which means that it can be easily converted to a DataFrame or similar.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"plot(block; label=\"CL price\")","category":"page"},{"location":"examples/#Creating-nodes","page":"Examples","title":"Creating nodes","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The core of TimeDag is a computational graph of TimeDag.Nodes. These nodes represent time-series, and how they should be computed in terms of other time-series.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can create a node from the block of data we already have:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"price = block_node(block)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The node knows its value_type, which will be Float64 (since the values will just be those of the block we created earlier).","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"value_type(price)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Now let's perform some computation — let's estimate the 50 day rolling standard deviation of returns.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We start by computing relative returns using lag; given a price p_t at time t, the return series is r_t = fracp_t - p_t-1p_t-1. We then use Statistics.std to define an online standard deviation over the specified window.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"returns = (price - lag(price, 1)) / lag(price, 1)\nusing Statistics\nstd_50 = std(returns, 50)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Whilst it isn't normally necessary to inspect the graph by hand, we can visualise it with AbstractTrees.print_tree. This is often good enough for a simple text-based representation, but be aware that actually we have a graph, and not a tree. In the output, the Lag node appears twice, however it is in fact exactly the same object.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using AbstractTrees\nprint_tree(std_50)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Now that we have defined our computation, we can evaluate it to form a concrete time-series. We use evaluate, and here we pass in a time range that covers all our input-data.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"By evaluating both returns and std_50 in the same call, note that we do not duplicate work. (See Advanced evaluation for further discussion on this.)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"returns_block, std_50_block = evaluate([returns, std_50], DateTime(2000), DateTime(2003))\n\nplot(returns_block; alpha=0.5, label=\"returns\")\nplot!(std_50_block; label=\"50 day std\")","category":"page"},{"location":"examples/#Other-sources","page":"Examples","title":"Other sources","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The example so far has used a source node that simply wraps data that is already held in memory. More interesting cases are nodes that read or generate their data only when evaluated.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Here we use Base.rand to generate a stream of random numbers. It produces a value whenever its argument ticks — in this case, iterdates will tick once a day at midnight.[2]","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"[2]: Note that TimeDag's time axis doesn't include timezone information.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"It is good practice to consider this time to always be in UTC.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"x = rand(iterdates())\nplot(evaluate(x, DateTime(2001), DateTime(2003)); label=\"[2001, 2003)\")\nplot!(evaluate(x, DateTime(2001), DateTime(2002)); label=\"[2001, 2002)\")","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"There are a couple of interesting things to note here:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can generate more data by evaluating over a longer range.\nSo long as we start at the same time, we get exactly the same random numbers.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This second property is a general property of node evaluation — repeated evaluation should always give the same answer.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Finally, we show the correlation for two random numbers over an expanding window. As expected, it converges towards zero as more data is observed:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"y = rand(iterdates())\ncorrelation = cor(x, y)\nplot(evaluate(correlation, DateTime(2001), DateTime(2002)); label=\"correlation\")","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Information on other source nodes included with TimeDag is available in Sources. If you wish to create your own source nodes, e.g. to read data directly from a database table, refer to Creating sources.","category":"page"},{"location":"reference/arithmetic/#Arithmetic","page":"Arithmetic","title":"Arithmetic","text":"","category":"section"},{"location":"reference/arithmetic/","page":"Arithmetic","title":"Arithmetic","text":"Base.abs\nBase.exp\nBase.log\nBase.log10\nBase.log2\nBase.sqrt\nBase.cbrt\nBase.inv\n\nBase.:+\nBase.:-\nBase.:*\nBase.:/\nBase.:^\nBase.min\nBase.max\nBase.:!\nBase.:>\nBase.:<\nBase.:>=\nBase.:<=","category":"page"},{"location":"reference/arithmetic/#Base.abs","page":"Arithmetic","title":"Base.abs","text":"abs(x::Node)\n\nObtain a node with values constructed by applying abs to each input value.\n\n\n\n\n\n","category":"function"},{"location":"reference/arithmetic/#Base.exp","page":"Arithmetic","title":"Base.exp","text":"exp(x::Node)\n\nObtain a node with values constructed by applying exp to each input value.\n\n\n\n\n\n","category":"function"},{"location":"reference/arithmetic/#Base.log","page":"Arithmetic","title":"Base.log","text":"log(x::Node)\n\nObtain a node with values constructed by applying log to each input value.\n\n\n\n\n\n","category":"function"},{"location":"reference/arithmetic/#Base.log10","page":"Arithmetic","title":"Base.log10","text":"log10(x::Node)\n\nObtain a node with values constructed by applying log10 to each input value.\n\n\n\n\n\n","category":"function"},{"location":"reference/arithmetic/#Base.log2","page":"Arithmetic","title":"Base.log2","text":"log2(x::Node)\n\nObtain a node with values constructed by applying log2 to each input value.\n\n\n\n\n\n","category":"function"},{"location":"reference/arithmetic/#Base.sqrt","page":"Arithmetic","title":"Base.sqrt","text":"sqrt(x::Node)\n\nObtain a node with values constructed by applying sqrt to each input value.\n\n\n\n\n\n","category":"function"},{"location":"reference/arithmetic/#Base.Math.cbrt","page":"Arithmetic","title":"Base.Math.cbrt","text":"cbrt(x::Node)\n\nObtain a node with values constructed by applying cbrt to each input value.\n\n\n\n\n\n","category":"function"},{"location":"reference/arithmetic/#Base.inv","page":"Arithmetic","title":"Base.inv","text":"inv(x::Node)\n\nObtain a node with values constructed by applying inv to each input value.\n\n\n\n\n\n","category":"function"},{"location":"reference/arithmetic/#Base.:+","page":"Arithmetic","title":"Base.:+","text":"+(x, y[, alignment=DEFAULT_ALIGNMENT; kwargs...])\n\nObtain a node with values constructed by applying + to the input values.\n\nAn alignment can optionally be specified. x and y should be nodes, or constants that can be converted to nodes.\n\nOther keyword arguments are passed to apply.\n\n\n\n\n\n","category":"function"},{"location":"reference/arithmetic/#Base.:-","page":"Arithmetic","title":"Base.:-","text":"-(x::Node)\n\nObtain a node with values constructed by applying - to each input value.\n\n\n\n\n\n-(x, y[, alignment=DEFAULT_ALIGNMENT; kwargs...])\n\nObtain a node with values constructed by applying - to the input values.\n\nAn alignment can optionally be specified. x and y should be nodes, or constants that can be converted to nodes.\n\nOther keyword arguments are passed to apply.\n\n\n\n\n\n","category":"function"},{"location":"reference/arithmetic/#Base.:*","page":"Arithmetic","title":"Base.:*","text":"*(x, y[, alignment=DEFAULT_ALIGNMENT; kwargs...])\n\nObtain a node with values constructed by applying * to the input values.\n\nAn alignment can optionally be specified. x and y should be nodes, or constants that can be converted to nodes.\n\nOther keyword arguments are passed to apply.\n\n\n\n\n\n","category":"function"},{"location":"reference/arithmetic/#Base.:/","page":"Arithmetic","title":"Base.:/","text":"/(x, y[, alignment=DEFAULT_ALIGNMENT; kwargs...])\n\nObtain a node with values constructed by applying / to the input values.\n\nAn alignment can optionally be specified. x and y should be nodes, or constants that can be converted to nodes.\n\nOther keyword arguments are passed to apply.\n\n\n\n\n\n","category":"function"},{"location":"reference/arithmetic/#Base.:^","page":"Arithmetic","title":"Base.:^","text":"^(x, y[, alignment=DEFAULT_ALIGNMENT; kwargs...])\n\nObtain a node with values constructed by applying ^ to the input values.\n\nAn alignment can optionally be specified. x and y should be nodes, or constants that can be converted to nodes.\n\nOther keyword arguments are passed to apply.\n\n\n\n\n\n","category":"function"},{"location":"reference/arithmetic/#Base.min","page":"Arithmetic","title":"Base.min","text":"min(x, y[, alignment=DEFAULT_ALIGNMENT; kwargs...])\n\nObtain a node with values constructed by applying min to the input values.\n\nAn alignment can optionally be specified. x and y should be nodes, or constants that can be converted to nodes.\n\nOther keyword arguments are passed to apply.\n\n\n\n\n\n","category":"function"},{"location":"reference/arithmetic/#Base.max","page":"Arithmetic","title":"Base.max","text":"max(x, y[, alignment=DEFAULT_ALIGNMENT; kwargs...])\n\nObtain a node with values constructed by applying max to the input values.\n\nAn alignment can optionally be specified. x and y should be nodes, or constants that can be converted to nodes.\n\nOther keyword arguments are passed to apply.\n\n\n\n\n\n","category":"function"},{"location":"reference/arithmetic/#Base.:!","page":"Arithmetic","title":"Base.:!","text":"!(x::Node)\n\nObtain a node with values constructed by applying ! to each input value.\n\n\n\n\n\n","category":"function"},{"location":"reference/arithmetic/#Base.:>","page":"Arithmetic","title":"Base.:>","text":">(x, y[, alignment=DEFAULT_ALIGNMENT; kwargs...])\n\nObtain a node with values constructed by applying > to the input values.\n\nAn alignment can optionally be specified. x and y should be nodes, or constants that can be converted to nodes.\n\nOther keyword arguments are passed to apply.\n\n\n\n\n\n","category":"function"},{"location":"reference/arithmetic/#Base.:<","page":"Arithmetic","title":"Base.:<","text":"<(x, y[, alignment=DEFAULT_ALIGNMENT; kwargs...])\n\nObtain a node with values constructed by applying < to the input values.\n\nAn alignment can optionally be specified. x and y should be nodes, or constants that can be converted to nodes.\n\nOther keyword arguments are passed to apply.\n\n\n\n\n\n","category":"function"},{"location":"reference/arithmetic/#Base.:>=","page":"Arithmetic","title":"Base.:>=","text":">=(x, y[, alignment=DEFAULT_ALIGNMENT; kwargs...])\n\nObtain a node with values constructed by applying >= to the input values.\n\nAn alignment can optionally be specified. x and y should be nodes, or constants that can be converted to nodes.\n\nOther keyword arguments are passed to apply.\n\n\n\n\n\n","category":"function"},{"location":"reference/arithmetic/#Base.:<=","page":"Arithmetic","title":"Base.:<=","text":"<=(x, y[, alignment=DEFAULT_ALIGNMENT; kwargs...])\n\nObtain a node with values constructed by applying <= to the input values.\n\nAn alignment can optionally be specified. x and y should be nodes, or constants that can be converted to nodes.\n\nOther keyword arguments are passed to apply.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = TimeDag","category":"page"},{"location":"#TimeDag","page":"Home","title":"TimeDag","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for TimeDag.jl!","category":"page"},{"location":"","page":"Home","title":"Home","text":"TimeDag enables you to build and run time-series models efficiently.","category":"page"},{"location":"","page":"Home","title":"Home","text":"You might want to use this package if some of the following apply:","category":"page"},{"location":"","page":"Home","title":"Home","text":"You are processing data with a natural time ordering.\nYou need to handle data sources that update irregularly.\nYou are building online-updating statistical models.\nYour input data is too large to fit in memory.\nYour system has several components that share similar computation.\nYou want to create a real-time system, but also test it over a large historical dataset.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package was built with Invenia's work in electricity grids in mind. Other domains that could be suitable include sensor, system monitoring, and financial market data.","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"It might be helpful to begin with the Concepts, and then to look at the Examples. After that, the documentation under Reference->Node ops should give an idea of what functionality is available.","category":"page"},{"location":"#Roadmap","page":"Home","title":"Roadmap","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This section indicates various core functionality that is either possible, or in progress:","category":"page"},{"location":"#Basic-operations","page":"Home","title":"Basic operations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[x] Lagging by fixed number of knots\n[x] Lagging by fixed time interval\n[x] Alignment of arbitrary numbers of node arguments to a node op","category":"page"},{"location":"#Source-node-ops","page":"Home","title":"Source node ops","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[x] In-memory, from an existing Block\n[x] From a Tea file\n[ ] From a generic Table, with some schema constraints","category":"page"},{"location":"#Array-values","page":"Home","title":"Array-values","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[ ] Nodes should be aware of the size of each value, when it is provably constant.","category":"page"},{"location":"#Statistics","page":"Home","title":"Statistics","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[x] Fixed-window sum, mean, std, cov, etc.\n[ ] Time-windowed sum, mean, standard-deviation, covariance, etc.\n[ ] Exponentially-weighted mean, std, cov, correlation\n[ ] Integration with OnlineStats.jl — should be easy to wrap an estimator into a node.","category":"page"},{"location":"#Evaluation-and-scheduling","page":"Home","title":"Evaluation & scheduling","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[x] Single-threaded evaluation of a graph\n[ ] Optimise value-independent ops by using alignment_base concept.\n[ ] Graph compilation / transformations\n[ ] Parallel evaluation of a batch within time-independent nodes\n[ ] Parallelising scheduler","category":"page"}]
}
